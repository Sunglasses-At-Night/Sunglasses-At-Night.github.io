<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="0x00000000.dev">





<title>Retrospective on Vulkan in DeltaBlade 2700 | 0x00000000 Blog</title>



    <link rel="icon" href="/favicon.ico">



<link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
<link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
<link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"><style>
.dark-color-main {
    background-color: #121212;
}
</style><style>.no-js img.lazyload {
    display: none;
}img[data-sizes="auto"] {
    display: block;
    width: 100%;
}</style></head>

<body class="dark-color-main text-light">
    <br><br><br><br>
    <div class="wrapper">
        <header>
    <style>
        .navbar {
            /* position: fixed; */
            top: 0;
            width: 100%;
            height: 6%;
            padding-top: 0px;
            padding-bottom: 0px;
            background: #5755d9;
            z-index: 5;
            position: absolute;
        }

        @media screen and (min-width: 170px) {
            .navbar {
                display: flex;
            }

            .main {
                padding-top: 0pt;
            }
        }
    </style>
    <!-- NAV -->
    <header class="navbar">
        <section class="navbar-section">
            <!-- <div class="navbar-header header-logo"><a href="/">0x00000000 Blog</a></div> -->
        </section>
        <section class="navbar-center">
            <a class="btn btn-link text-light" href="/">Home</a>
            
                <a class="btn btn-link text-light" href="/archives">
                    Posts
                </a>
                
                <a class="btn btn-link text-light" href="/tags">
                    Tags
                </a>
                
        </section>
        <section class="navbar-section">
            <!-- <input id="switch_default" type="checkbox" class="switch_default"> -->
            <!-- <label for="switch_default" class="toggleBtn"></label> -->
        </section>
    </header>
</header>
<br><br>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
        <article class="post-wrap columns">
            <style>
                .div-only-mobile {
                    display: none;
                }

                .div-no-mobile {
                    display: block;
                }

                @media screen and (max-width: 1280px) {
                    .div-no-mobile {
                        display: none
                    }

                    .div-only-mobile {
                        display: block;
                    }
                }

                ul {
                    list-style-position: outside;
                }

                ol ol, ol ul, ul ol, ul ul {
                    margin: 0 0 0 0;
                }

                .text-light {
                    color: #e8e8e8!important;
                }

            </style>
            <div class="column col-xl-2"></div>
            <div class="column col-8 col-xl-12">
                <header class="post-header">
                    <h1 class="post-title">
                        Retrospective on Vulkan in DeltaBlade 2700
                    </h1>
                    
                        <div class="post-meta">
                            
                                <a class="text-light">Author: </a><a class="text-gray">
                                        Jonathan Bourim
                                    </a>
                                
                                    <br>
                                    
                                        <a class="text-light">Date: </a><a class="text-gray">
                                                December 5, 2021
                                            </a>
                                        
                                <br>
                                <a class="text-light">Views: <script>document.write('<img src="//counter.websiteout.net/compte.php?S='+encodeURI(window.location.href)+'&C=9&D=0&N=0&M=0" alt="" border="0"/>');</script></a>
                        </div>
                        
                </header>
                <div class="post-content">
                    <p><noscript><img src="/images/Vulkan/vulkan_logo.png"></noscript><img src="/images/LazyLoad.png" data-src="/images/Vulkan/vulkan_logo.png" class="lazyload"></p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><strong>Vulkan</strong> is a low-level, cross-platform rendering API that is designed to abstract modern graphics architectures while maintaining the maximum level of programmability. Before Vulkan, programmers would use APIs such as OpenGL and D3D11 for rendering. As real-time simulation matured, graphics programmers were looking for ways to optimize the rendering pipeline for their specific uses. With previous APIs, this was a massive limitation. Now, with the release of Vulkan, programmers now have more control than ever in specifying all details of a program’s rendering functionality. </p>
<p>As DeltaBlade 2700 is intended to be a game enjoyed on as many platforms as possible, particularly the Nintendo Switch, the usage of Vulkan as our rendering backend seemed both a fantastic use-case of the API, as well as a valuable learning experience for myself and others. As the project continues development, so will the graphics framework that hosts the rendering functionality, entitled <strong>Damascus</strong>. </p>
<h1 id="Personal-Project-Goals"><a href="#Personal-Project-Goals" class="headerlink" title="Personal Project Goals"></a>Personal Project Goals</h1><p>My personal goal for the project is the development of Damascus into a multi-featured graphics framework, including:</p>
<ul>
<li><p>Triple Buffering, allowing frames to be processed while the previous frame is still in-flight.</p>
</li>
<li><p>Abstraction of all basic types for automatic memory management, extensibility and convenient construction (particularly for asynchronous rendering, where you need stored copies of each type).</p>
</li>
<li><p>Abstracted rendering pipeline creation to speed up development time and reduce code duplication.</p>
</li>
<li><p>Renderer API, allowing a user to simply add a rendering context with associated pipelines.</p>
</li>
</ul>
<h1 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h1><h2 id="Triple-Buffering"><a href="#Triple-Buffering" class="headerlink" title="Triple Buffering"></a>Triple Buffering</h2><p>Traditional rendering APIs like OpenGL assume that all rendering commands are executed before the beginning of the next render pass. This means that the GPU will stall and wait until all the commands have been executed and everything has been rasterized to the screen before continuing program execution. This is a tremendous amount of unnecessary waiting. </p>
<p>To alleviate this, triple buffering is a technique that uses multiple instances of each rendering object within the engine, so that one set may be being executed / rendered while another is already being processed for execution thereafter. </p>
<p><a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Samples/blob/master/samples/performance/swapchain_images/swapchain_images_tutorial.md">An example can be found in the Khronos Group Vulkan Samples by clicking here.</a></p>
<p>The success of this implementation is determined by the relative framerate improvements using only a single object per swapchain image (single-buffered) as all programs would by default, versus the framerate improvements of introducing the additional images and in-flight processing. </p>
<h2 id="Vulkan-Type-Abstraction"><a href="#Vulkan-Type-Abstraction" class="headerlink" title="Vulkan Type Abstraction"></a>Vulkan Type Abstraction</h2><p>Vulkan types are effectively pointers that are provided from their respective <code>Create</code> functions to an opaque handle. Before that, they are “null handles” and contain only a null address. One of the most common techniques a Vulkan framework can do is take control of type creation, usage and destruction of these basic types.</p>
<p>Damascus extends these basic types to functionally serve as the underlying Vulkan type, extend class information for our own purposes, as well as self-destruct when leaving scope if the underlying type has initialized memory.</p>
<p>The success of this implementation is determined by the program’s ability to execute custom user code, as well as perform automatic cleanup on leaving scope and exiting the program. As Vulkan validation layers and Vulkan Memory Allocator will explicitly error if memory isn’t freed, this is easy to evaluate.</p>
<h2 id="Render-Pipeline-Abstraction"><a href="#Render-Pipeline-Abstraction" class="headerlink" title="Render Pipeline Abstraction"></a>Render Pipeline Abstraction</h2><p>Construction of a full rendering pipeline is a non-trivial endeavor in Vulkan. There’s so much to describe, in fact, that they’re introducing features to mitigate the amount of information required to construct one. </p>
<p><a target="_blank" rel="noopener" href="https://www.khronos.org/blog/streamlining-render-passes">Click here to see a blog post describing the upcoming changes to streamline render passes.</a></p>
<p>As mentioned in the post, construction of these objects remains largely verbose because the API needed to ship, and it particularly needed to provide the ability to describe subpasses (mini-passes inside of your render pipeline, in a sense) for users leveraging something like tiled deferred rendering. However, if you aren’t making use of these features, it’s a ton of boilerplate code.</p>
<p>In addition, half of the battle in any Vulkan framework is the description of shader resources, particularly in a program that has dynamic state. It’s relatively straightforward to describe a set amount of resources to be used in perpetuity when you’re aware of the entire state of your program ahead of time, but in a game where the state can change at any time… this becomes dramatically more challenging. In addition, there are a surprisingly small number of resources that deal with this issue, as most usages of Vulkan online are for demo programs.</p>
<p>Several goals during this project is to construct a pipeline capable of allocating, utilizing and cleaning up these pipelines and resources at runtime with dynamic state.</p>
<p>Evaluating this pipeline will be the ease of construction and utilization of new shaders, render passes and object uniforms that provide their data to them.</p>
<h2 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a>Renderer</h2><p>As the use of Vulkan is so explicit, the construction of any rendering code is essentially the practice of stating your “assumptions” of the render state. This will be the process of effectively defining my own default state, similarly to how <em>OpenGL</em> would behave if you were to leave all its internal settings to their default values.</p>
<p>Damascus defines its own <code>Renderer</code> class, which allows users to append a <code>IRenderingContext</code>, which is effectively a way to describe a single application’s render state. An <code>IRenderingContext</code> contains a series of graphics pipelines and describes how they interact with one another to achieve the user’s desired output.</p>
<p>This will be evaluated once again by the ease of use, particularly in the ability to add rendering functionality to the program at whim.</p>
<h1 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h1><h2 id="Triple-Buffering-1"><a href="#Triple-Buffering-1" class="headerlink" title="Triple Buffering"></a>Triple Buffering</h2><p>This was done by simply tripling the quantity of every Vulkan resource that gets utilized on the GPU, allowing subsequent frames to be processed during in-flight rendering.</p>
<p>This is done quite simply by declaring a type called ImageAsync, which is just another way of describing a vector, but we use this semantic to inform that this is intended to be initialized per-swapchain-image.</p>
<h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">ImageAsync</span>&lt;T&gt; = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;T&gt;;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Usage-Example"><a href="#Usage-Example" class="headerlink" title="Usage Example"></a>Usage Example</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ImageAsync&lt;std::array&lt;vk::ImageView, ForwardPipeline::Attachments::Count&gt;&gt; ForwardPipeline::GetAttachmentsCreateInfo()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">auto</span>&amp; renderer = Renderer();</span><br><span class="line">    <span class="keyword">auto</span>&amp; rc = renderer.GetRenderingContext&lt;GameRenderingContext&gt;();</span><br><span class="line"></span><br><span class="line">    ImageAsync&lt;<span class="built_in">std</span>::<span class="built_in">array</span>&lt;vk::ImageView, Attachments::Count&gt;&gt; attachmentsPerImage;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Renderer().ImageCount(); ++i)</span><br><span class="line">    {</span><br><span class="line">        attachmentsPerImage.push_back({</span><br><span class="line">            rc.attachments[GameRenderingContext::Attachments::Color].imageView.VkType(),</span><br><span class="line">            rc.attachments[GameRenderingContext::Attachments::Depth].imageView.VkType(),</span><br><span class="line">#ifdef USE_MSAA</span><br><span class="line">            rc.attachments[GameRenderingContext::Attachments::ResolveColor].imageView.VkType(),</span><br><span class="line">#endif</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> attachmentsPerImage;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This has had great results on performance, increasing our rendering output by several folds. As with most applications, we were certainly spending a large amount of time waiting for the GPU to finish executing commands. Now we can begin working on our next frame’s data before having completed the previous.</p>
<h2 id="Vulkan-Type-Abstraction-1"><a href="#Vulkan-Type-Abstraction-1" class="headerlink" title="Vulkan Type Abstraction"></a>Vulkan Type Abstraction</h2><p>The primary goals for this type abstraction were:</p>
<ul>
<li>Extensibility</li>
<li>Conversion to underlying vulkan type</li>
<li>Automatic cleanup</li>
</ul>
<p>In order to accomplish this, Damascus defines a typical Vulkan type like this:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameBuffer</span> :</span> <span class="keyword">public</span> IVulkanType&lt;vk::Framebuffer&gt;, <span class="keyword">public</span> IOwned&lt;Device&gt;</span><br><span class="line">{</span><br><span class="line">	DM_TYPE_VULKAN_OWNED_BODY(FrameBuffer, IOwned&lt;Device&gt;)</span><br><span class="line">	DM_TYPE_VULKAN_OWNED_GENERIC(FrameBuffer, Framebuffer)</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>To break it down a bit, </p>
<p><code>IVulkanType</code> is responsible for declaring the underlying type and defines several conversion functions, such as <code>VkType()</code> and <code>VkCType()</code>, which convert to the C++ and C vulkan types respectively.</p>
<p><code>IOwned</code> handles memory cleanup, and defines a pointer to the owning type. Along with some user-defined destructor and dependency injection, this automatically cleans up the memory using this inheritance model upon leaving scope.</p>
<p>The macros are simply a way of avoiding writing Vulkan construction code for a simple type, as almost all vulkan types are constructed and destructed using the same semantic model.</p>
<p>I.E.: <code>device-&gt;createSemaphore(&amp;createInfo, nullptr, &amp;VkType())...</code>    </p>
<p>This has been tremendously successful, as all of our abstractions leverage these types. With the sheer number of objects constructed, the automatic cleanup has been <em>vital</em> for avoiding serious memory leaks.</p>
<h2 id="Render-Pipeline-Abstraction-1"><a href="#Render-Pipeline-Abstraction-1" class="headerlink" title="Render Pipeline Abstraction"></a>Render Pipeline Abstraction</h2><h3 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h3><p>In order to simplify the construction and utilization of pipelines, I use an <code>IGraphicsPipeline</code> to define a base interface that the <code>RenderingContext</code> is capable of invoking for a pipeline of any type.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Load</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Create</span><span class="params">(Device* inOwner)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRecreateSwapchain</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteUniformSets</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">float</span> dt)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> vk::CommandBuffer* <span class="title">Record</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>This allows the rendering context to enumerate over pipeline containers and perform everything we need for creation, loading, updating and recording.</p>
<h3 id="Descriptor-Sets"><a href="#Descriptor-Sets" class="headerlink" title="Descriptor Sets"></a>Descriptor Sets</h3><p>Descriptor sets, as mentioned in the details, were a massive challenge. In order to construct a program capable of dynamic state, you need an entire pipeline that is capable of understanding the necessary memory from the contents of a shader, creating the associated memory upon request, and associating objects with that memory.</p>
<p>I’m happy to say that this process is now fully functional within Damascus with minimal overhead, albeit this is only permissible due to the simplicity of our game.</p>
<p>In order to accomplish this, we do the following:</p>
<ul>
<li>Add and create all pipelines intended to be used by the rendering context at load-time</li>
<li>Upon loading the pipeline, shader reflection reads in all descriptor sets and bindings that the pipeline will be utilizing</li>
<li>All possible descriptor sets and bindings are frontloaded for this pipeline with maximum value counts for each set and binding type, which is created using a pooling model.</li>
<li>These memory pools provide objects with an <em>available ID</em> for use, which is a window into that object’s memory region in the uniform / binding’s data.</li>
<li>Objects can now interface with these bindings directly, primarily by providing their local uniform data to the staging buffers contained within each binding.</li>
<li>These bindings / uniforms are uploaded each frame from the CPU to the GPU if their memory has been written-to.</li>
</ul>
<p>The user interface for this process has been intentionally kept minimal.</p>
<p>Users begin by creating a uniform type associated with a pipeline:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CUniformsForward</span> <span class="title">final</span> :</span> IUniforms&lt;ForwardPipeline&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>They define bindings that the shader uses locally:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Bindings : <span class="keyword">uint32_t</span></span><br><span class="line">{</span><br><span class="line">    SampleProperties = <span class="number">0</span>,</span><br><span class="line">    TransformModifiers = <span class="number">1</span>,</span><br><span class="line">    DebugProperties = <span class="number">2</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UboTransformModifiers</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    glm::vec4 position = glm::vec4(<span class="number">0.0f</span>);</span><br><span class="line">    glm::vec4 scale = glm::vec4(<span class="number">1.0f</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UboSampleProperties</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    glm::vec2 uvScale = glm::vec2(<span class="number">1.0f</span>);</span><br><span class="line">    glm::vec2 uvOffset = glm::vec2(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> sampleIndex = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UboDebugProperties</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    glm::vec4 colorModifier = glm::vec4(<span class="number">1.0f</span>);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>Then, they overload the assign function, which loads the local data into the staging buffer of the uniform to be ready for transport to the GPU:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assign</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    objectUniforms-&gt;SetUniformBufferData(sampleProperties, Bindings::SampleProperties);</span><br><span class="line">    objectUniforms-&gt;SetUniformBufferData(transformModifiers, Bindings::TransformModifiers);</span><br><span class="line">    objectUniforms-&gt;SetUniformBufferData(debugProperties, Bindings::DebugProperties);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This allows a user to interface with an object’s uniforms by simply changing the value of the member variables listed above, as the backend will handle the rest.</p>
<p>While construction of this pipeline was quite difficult to construct and validate, the results have justified the time spent. This has been a convenient pipeline to work with in terms of CPU to GPU interfacing with shader resources. This pipeline has served as the backbone for the post-processor, particle system, debug rendering, text rendering and more.</p>
<h2 id="Renderer-1"><a href="#Renderer-1" class="headerlink" title="Renderer"></a>Renderer</h2><p>The process of stating a simple set of rendering state assumptions has worked wonders for just keeping the rendering state clean and functional. We do that using the following concepts:</p>
<h3 id="Rendering-Contexts"><a href="#Rendering-Contexts" class="headerlink" title="Rendering Contexts"></a>Rendering Contexts</h3><p>In order to define all the pipelines we’d like in the <code>GameRenderingContext</code> for example, we define these pipelines in the order we’d like them to execute.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GameRenderingContext::CreatePipelines</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    AddPipeline&lt;DeferredPipeline&gt;();</span><br><span class="line">    AddPipeline&lt;SampleDeferredPipeline&gt;();</span><br><span class="line">    AddPipeline&lt;ForwardPipeline&gt;();</span><br><span class="line">    AddPipeline&lt;ForwardInstancedPipeline&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add post-processing pipelines</span></span><br><span class="line">    PostFX::instance-&gt;AddEffectPipelines();</span><br><span class="line"></span><br><span class="line">    AddPipeline&lt;SamplePostPipeline&gt;();</span><br><span class="line">    AddPipeline&lt;TextPipeline&gt;();</span><br><span class="line">    AddPipeline&lt;DebugPipeline&gt;();</span><br><span class="line">    AddPipeline&lt;OutputPipeline&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [id, pipeline] : pipelines)</span><br><span class="line">        pipeline-&gt;Create(&amp;renderer.device);</span><br></pre></td></tr></tbody></table></figure>

<p>The pipelines will execute in series, handing the rendering output from one to the next like a game of hot potato (particularly in the case of the <code>PostFX</code> post-processing pipeline).</p>
<p>When it comes time to record, they’ll also execute in series, with the next pipeline executing only the previous has completed. This is not the most performant method, but greatly decreases the complexity of our game.</p>
<p>This is similarly done for the editor rendering context, creating the context for the editor UI of the project.</p>
<p>The rendering context is added to the renderer via an <code>AddRenderingContext</code> call, which will enumerate these contexts for various purposes.</p>
<h3 id="Update-phase"><a href="#Update-phase" class="headerlink" title="Update phase"></a>Update phase</h3><p>For the update phase, it is important to test if any uniforms we’ve created have been dirtied as a result of operations that may have occurred earlier in the update phase (renderer updates last).</p>
<p>This will traverse the list of rendering contexts and pipelines to identify if any descriptors need to be written to. Each pipeline overloads its own <code>WriteUniformSets</code> function that determines how to assign the <code>DescriptorSet</code> to its associated GPU memory.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForwardPipeline::WriteUniformSets</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    X::Update&lt;CUniformsForward&gt;(</span><br><span class="line">        [](X::Space&amp; space, <span class="keyword">const</span> X::Entity entity, CUniformsForward&amp; uniforms) {</span><br><span class="line">            uniforms.WriteObjectUniforms();</span><br><span class="line">            uniforms.Assign();</span><br><span class="line">        });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Here <code>CUniformsForward</code> describes the associated uniform component for the pipeline.<br>We iterate over the entities that happen to contain this component and write the sets for the object, then assign the local CPU-bound memory to the staging buffer within the uniform binding. This is then automatically uploaded to the GPU during the rendering phase.</p>
<h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><p>The primary use of these contexts is, of course, to record the drawing commands to provide the window with visual output.</p>
<p>The renderer executes at the last phase of the engine, and will aggregate all the rendering commands of each context. This includes:</p>
<ul>
<li>Uploading uniforms to the global uniform set</li>
<li>Recording the render commands of each context and pipeline therein<ul>
<li>Uploads uniforms associated with the pipeline</li>
<li>Rendering each object that is assigned to the pipeline</li>
</ul>
</li>
</ul>
<p>Recording example in a pipeline:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">renderQueue.Submit(</span><br><span class="line">    RenderPassBucket::FORWARD,</span><br><span class="line">    [&amp;renderer, commandBuffer, layout](<span class="keyword">const</span> X::ComponentWrapperGeneric&amp; wrapper) {</span><br><span class="line">        <span class="comment">// Bind mesh</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; render = wrapper.GetComponent&lt;CRender&gt;();</span><br><span class="line"></span><br><span class="line">        render.mesh.Bind(commandBuffer);</span><br><span class="line"></span><br><span class="line">        wrapper.GetComponent&lt;CUniformsForward&gt;().BindObjectUniforms(renderer.imageIndex, commandBuffer, layout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Submit transform data</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; transform = wrapper.GetComponent&lt;CTransform&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> mat4 = transform.Global(wrapper.GetSpace(), wrapper.GetEntity()).GetMat4();</span><br><span class="line">        commandBuffer.pushConstants(</span><br><span class="line">            layout,</span><br><span class="line">            vk::ShaderStageFlagBits::eVertex,</span><br><span class="line">            <span class="number">0</span>, <span class="keyword">sizeof</span>(glm::mat4), &amp;mat4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Display mesh</span></span><br><span class="line">        render.mesh.Draw(commandBuffer);</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure>

<p>All rendering functionality in the project utilizes this model, and we’ve found good success in terms of performance and ease of validation using this sequence. </p>
<h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><h2 id="Technical-Rabbit-Holes"><a href="#Technical-Rabbit-Holes" class="headerlink" title="Technical Rabbit Holes"></a>Technical Rabbit Holes</h2><p>People often speak about how they prefer C to C++ because of the possibility of getting caught inside of infinite technical rabbit holes in the attempt to cover every possible use-case of their systems.</p>
<p>Well, I hadn’t really experienced it up until working on Damascus, but I now agree with that more than ever! In the process of abstracting the vulkan types in particular, that model had undergone dozens of changes until it landed on what’s being used now. This soaked a tremendous amount of time ahead of the project’s startup. </p>
<p>This still happens of course, but that process has taught me a very valuable lesson about how one can really spend all their time in a corner until they take a step back and look at the bigger picture.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>All in all this has been an incredibly fruitful project in terms of furthering my understanding of low-level rendering. The original goals were almost entirely accomplished. There is quite a lot I wish I could’ve done, but the existing features are something I’m proud of. Had I stuck with my familiar choice, <em>OpenGL</em>, the project would have certainly benefited from a ton of features… but I wouldn’t have learned anywhere near the same quantity about professional graphics programming.</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><h2 id="Vulkan-Samples"><a href="#Vulkan-Samples" class="headerlink" title="Vulkan Samples"></a><a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/Vulkan-Samples">Vulkan Samples</a></h2><p>Official Vulkan samples by the Khronos Group, covering many different concepts and some Do’s and Don’t Do’s for different techniques and types.</p>
<h2 id="VkGuide"><a href="#VkGuide" class="headerlink" title="VkGuide"></a><a target="_blank" rel="noopener" href="https://vkguide.dev/">VkGuide</a></h2><p>Used as a resource while developing many different elements of the framework, namely descriptor sets, texture handling, etc. A lovely resource describing many different mental models, code examples, and more.</p>
<h2 id="Lessons-Learned-Building-a-Vulkan-Material-System"><a href="#Lessons-Learned-Building-a-Vulkan-Material-System" class="headerlink" title="Lessons Learned Building a Vulkan Material System"></a><a target="_blank" rel="noopener" href="http://kylehalladay.com/blog/tutorial/2017/11/27/Vulkan-Material-System.html">Lessons Learned Building a Vulkan Material System</a></h2><p>Resource used to develop descriptor sets, shader reflection, render pipeline creation etc. </p>

                </div>
                
                        <section class="post-tags">
                            <div>
                                <span>Tag(s):</span>
                                <span class="tag">
                                    
                                        
                                            <a href="/tags/Game/"># Game</a>
                                            
                                            <a href="/tags/DeltaBlade-2700/"># DeltaBlade 2700</a>
                                            
                                            <a href="/tags/Vulkan/"># Vulkan</a>
                                            
                                            <a href="/tags/Graphics/"># Graphics</a>
                                            
                                            <a href="/tags/Damascus/"># Damascus</a>
                                            
                                                
                                </span>
                            </div>
                            <div>
                                <a href="javascript:window.history.back();">back</a>
                                <span>· </span>
                                <a href="/">home</a>
                            </div>
                        </section>
                        <section class="post-nav">
                            
                                <a class="prev" rel="prev" href="/pianoviz/">
                                    The making of PianoViz - An augmented Reality Piano Assistant
                                </a>
                                
                                    
                                        <a class="next" rel="next" href="/alloy-ecs-1/">
                                            Alloy Entity Component System - Retrospective
                                        </a>
                                        
                        </section>
            </div>
            <div class="column col-xl-2">
                
                    
                        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
                            
            </div>
        </article>
</div>
        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
<!-- © 0x00000000.dev |  -->
        <span>Powered by <a href="https://hexo.io" target="_blank">Hexo</a></span>
    </div>
</footer>

    </div>


</body><script>!function(e,t){var r=function(){t(e.lazySizes),e.removeEventListener("lazyunveilread",r,!0)};t=t.bind(null,e,e.document),"object"==typeof module&&module.exports?t(require("lazysizes")):e.lazySizes?r():e.addEventListener("lazyunveilread",r,!0)}(window,function(u,a,d){"use strict";var i,n,s,l,t,r,p,o,c,f,m,y=d&&d.cfg,e=a.createElement("img"),g="sizes"in e&&"srcset"in e,h=/\s+\d+h/g,e=(n=/\s+(\d+)(w|h)\s+(\d+)(w|h)/,s=Array.prototype.forEach,function(){function r(e){var t,r=e.getAttribute(lazySizesConfig.srcsetAttr);r&&(t=r.match(n))&&((t="w"==t[2]?t[1]/t[3]:t[3]/t[1])&&e.setAttribute("data-aspectratio",t),e.setAttribute(lazySizesConfig.srcsetAttr,r.replace(h,"")))}function e(e){var t;e.detail.instance==d&&((t=e.target.parentNode)&&"PICTURE"==t.nodeName&&s.call(t.getElementsByTagName("source"),r),r(e.target))}function t(){i.currentSrc&&a.removeEventListener("lazybeforeunveil",e)}var i=a.createElement("img");a.addEventListener("lazybeforeunveil",e),i.onload=t,i.onerror=t,i.srcset="data:,a 1w 1h",i.complete&&t()});function z(e,t){return e.w-t.w}function v(e,t,r,i){l.push({c:t,u:r,w:+i})}function b(e,t){var r,i=e.getAttribute("srcset")||e.getAttribute(y.srcsetAttr);!i&&t&&(i=e._lazypolyfill?e._lazypolyfill._set:e.getAttribute(y.srcAttr)||e.getAttribute("src")),e._lazypolyfill&&e._lazypolyfill._set==i||(r=o(i||""),t&&e.parentNode&&(r.isPicture="PICTURE"==e.parentNode.nodeName.toUpperCase(),r.isPicture&&u.matchMedia&&(d.aC(e,"lazymatchmedia"),c())),r._set=i,Object.defineProperty(e,"_lazypolyfill",{value:r,writable:!0}))}function w(e){var t,r,i,a,n,s,l,o,c=e;if(b(c,!0),(a=c._lazypolyfill).isPicture)for(r=0,i=(t=e.parentNode.getElementsByTagName("source")).length;r<i;r++)if(y.supportsType(t[r].getAttribute("type"),e)&&f(t[r].getAttribute("media"))){c=t[r],b(c),a=c._lazypolyfill;break}return 1<a.length?(s=c.getAttribute("sizes")||"",s=p.test(s)&&parseInt(s,10)||d.gW(e,e.parentNode),a.d=(l=e,o=u.devicePixelRatio||1,l=d.getX&&d.getX(l),Math.min(l||o,2.5,o)),!a.src||!a.w||a.w<s?(a.w=s,n=function(e){for(var t,r,i=e.length,a=e[i-1],n=0;n<i;n++)if((a=e[n]).d=a.w/e.w,a.d>=e.d){!a.cached&&(t=e[n-1])&&t.d>e.d-.13*Math.pow(e.d,2.2)&&(r=Math.pow(t.d-.6,1.6),t.cached&&(t.d+=.15*r),t.d+(a.d-e.d)*r>e.d&&(a=t));break}return a}(a.sort(z)),a.src=n):n=a.src):n=a[0],n}function A(e){var t;g&&e.parentNode&&"PICTURE"!=e.parentNode.nodeName.toUpperCase()||(t=w(e))&&t.u&&e._lazypolyfill.cur!=t.u&&(e._lazypolyfill.cur=t.u,t.cached=!0,e.setAttribute(y.srcAttr,t.u),e.setAttribute("src",t.u))}y.supportsType||(y.supportsType=function(e){return!e}),u.HTMLPictureElement&&g?!d.hasHDescriptorFix&&a.msElementsFromPoint&&(d.hasHDescriptorFix=!0,e()):u.picturefill||y.pf||(y.pf=function(e){var t,r;if(!u.picturefill)for(t=0,r=e.elements.length;t<r;t++)i(e.elements[t])},p=/^\s*\d+\.*\d*px\s*$/,t=/(([^,\s].[^\s]+)\s+(\d+)w)/g,r=/\s/,c=function(){var e,r;function t(){for(var e=0,t=r.length;e<t;e++)i(r[e])}c.init||(c.init=!0,addEventListener("resize",(r=a.getElementsByClassName("lazymatchmedia"),function(){clearTimeout(e),e=setTimeout(t,66)})))},f=function(e){return u.matchMedia?(f=function(e){return!e||(matchMedia(e)||{}).matches})(e):!e},A.parse=o=function(e){return l=[],(e=e.trim()).replace(h,"").replace(t,v),l.length||!e||r.test(e)||l.push({c:e,u:e,w:99}),l},i=A,y.loadedClass&&y.loadingClass&&(m=[],['img[sizes$="px"][srcset].',"picture > img:not([srcset])."].forEach(function(e){m.push(e+y.loadedClass),m.push(e+y.loadingClass)}),y.pf({elements:a.querySelectorAll(m.join(", "))})))});</script><script>!function(e,t){t=t(e,e.document);e.lazySizes=t,"object"==typeof module&&module.exports&&(module.exports=t)}(window,function(a,m){"use strict";if(m.getElementsByClassName){var z,n,i,t,s,o,y=m.documentElement,r=a.Date,l=a.HTMLPictureElement,c="addEventListener",h="getAttribute",d=a[c],u=a.setTimeout,f=a.requestAnimationFrame||u,v=a.requestIdleCallback,g=/^picture$/i,p=["load","error","lazyincluded","_lazyloaded"],C={},b=Array.prototype.forEach,A=function(e,t){return C[t]||(C[t]=new RegExp("(\\s|^)"+t+"(\\s|$)")),C[t].test(e[h]("class")||"")&&C[t]},E=function(e,t){A(e,t)||e.setAttribute("class",(e[h]("class")||"").trim()+" "+t)},_=function(e,t){(t=A(e,t))&&e.setAttribute("class",(e[h]("class")||"").replace(t," "))},w=function(t,n,e){var a=e?c:"removeEventListener";e&&w(t,n),p.forEach(function(e){t[a](e,n)})},M=function(e,t,n,a,i){var s=m.createEvent("Event");return(n=n||{}).instance=ue,s.initEvent(t,!a,!i),s.detail=n,e.dispatchEvent(s),s},N=function(e,t){var n;!l&&(n=a.picturefill||z.pf)?(t&&t.src&&!e[h]("srcset")&&e.setAttribute("srcset",t.src),n({reevaluate:!0,elements:[e]})):t&&t.src&&(e.src=t.src)},x=function(e,t){return(getComputedStyle(e,null)||{})[t]},W=function(e,t,n){for(n=n||e.offsetWidth;n<z.minSize&&t&&!e._lazysizesWidth;)n=t.offsetWidth,t=t.parentNode;return n},T=(s=[],o=t=[],he._lsFlush=ye,he),e=function(n,e){return e?function(){T(n)}:function(){var e=this,t=arguments;T(function(){n.apply(e,t)})}},B=function(e){var t,n,a=function(){t=null,e()},i=function(){var e=r.now()-n;e<99?u(i,99-e):(v||a)(a)};return function(){n=r.now(),t=t||u(i,99)}};!function(){var e,t={lazyClass:"lazyload",loadedClass:"lazyloaded",loadingClass:"lazyloading",preloadClass:"lazypreload",errorClass:"lazyerror",autosizesClass:"lazyautosizes",srcAttr:"data-src",srcsetAttr:"data-srcset",sizesAttr:"data-sizes",minSize:40,customMedia:{},init:!0,expFactor:1.5,hFac:.8,loadMode:2,loadHidden:!0,ricTimeout:0,throttleDelay:125};for(e in z=a.lazySizesConfig||a.lazysizesConfig||{},t)e in z||(z[e]=t[e]);a.lazySizesConfig=z,u(function(){z.init&&ze()})}();var F,S,L,R,k,D,H,O,P,$,I,q,j,G,J,K,Q,U,V,X,Y,Z,ee,te,ne,ae,ie,se,oe,re,le,ce,de,ue,fe=(V=/^img$/i,X=/^iframe$/i,Y="onscroll"in a&&!/(gle|ing)bot/.test(navigator.userAgent),te=-1,j=pe,J=ee=Z=0,K=z.throttleDelay,Q=z.ricTimeout,U=v&&49<Q?function(){v(Ce,{timeout:Q}),Q!==z.ricTimeout&&(Q=z.ricTimeout)}:e(function(){u(Ce)},!0),ae=e(be),ie=function(e){ae({target:e.target})},se=e(function(t,e,n,a,i){var s,o,r,l;(r=M(t,"lazybeforeunveil",e)).defaultPrevented||(a&&(n?E(t,z.autosizesClass):t.setAttribute("sizes",a)),n=t[h](z.srcsetAttr),a=t[h](z.srcAttr),i&&(o=(s=t.parentNode)&&g.test(s.nodeName||"")),l=e.firesLoad||"src"in t&&(n||a||o),r={target:t},E(t,z.loadingClass),l&&(clearTimeout(L),L=u(ve,2500),w(t,ie,!0)),o&&b.call(s.getElementsByTagName("source"),Ae),n?t.setAttribute("srcset",n):a&&!o&&(X.test(t.nodeName)?function(t,n){try{t.contentWindow.location.replace(n)}catch(e){t.src=n}}(t,a):t.src=a),i&&(n||o)&&N(t,{src:a})),t._lazyRace&&delete t._lazyRace,_(t,z.lazyClass),T(function(){var e=t.complete&&1<t.naturalWidth;l&&!e||(e&&E(t,"ls-is-cached"),be(r),t._lazyCache=!0,u(function(){"_lazyCache"in t&&delete t._lazyCache},9))},!0)}),re=function(){var e;S||(r.now()-k<999?u(re,999):(e=B(function(){z.loadMode=3,ne()}),S=!0,z.loadMode=3,ne(),d("scroll",function(){3==z.loadMode&&(z.loadMode=2),e()},!0)))},{_:function(){k=r.now(),ue.elements=m.getElementsByClassName(z.lazyClass),F=m.getElementsByClassName(z.lazyClass+" "+z.preloadClass),d("scroll",ne,!0),d("resize",ne,!0),a.MutationObserver?new MutationObserver(ne).observe(y,{childList:!0,subtree:!0,attributes:!0}):(y[c]("DOMNodeInserted",ne,!0),y[c]("DOMAttrModified",ne,!0),setInterval(ne,999)),d("hashchange",ne,!0),["focus","mouseover","click","load","transitionend","animationend","webkitAnimationEnd"].forEach(function(e){m[c](e,ne,!0)}),/d$|^c/.test(m.readyState)?re():(d("load",re),m[c]("DOMContentLoaded",ne),u(re,2e4)),ue.elements.length?(pe(),T._lsFlush()):ne()},checkElems:ne=function(e){var t;(e=!0===e)&&(Q=33),G||(G=!0,(t=K-(r.now()-J))<0&&(t=0),e||t<9?U():u(U,t))},unveil:oe=function(e){var t,n=V.test(e.nodeName),a=n&&(e[h](z.sizesAttr)||e[h]("sizes")),i="auto"==a;(!i&&S||!n||!e[h]("src")&&!e.srcset||e.complete||A(e,z.errorClass)||!A(e,z.lazyClass))&&(t=M(e,"lazyunveilread").detail,i&&me.updateElem(e,!0,e.offsetWidth),e._lazyRace=!0,ee++,se(e,t,i,a,n))}}),me=(ce=e(function(e,t,n,a){var i,s,o;if(e._lazysizesWidth=a,e.setAttribute("sizes",a+="px"),g.test(t.nodeName||""))for(s=0,o=(i=t.getElementsByTagName("source")).length;s<o;s++)i[s].setAttribute("sizes",a);n.detail.dataAttr||N(e,n.detail)}),{_:function(){le=m.getElementsByClassName(z.autosizesClass),d("resize",de)},checkElems:de=B(function(){var e,t=le.length;if(t)for(e=0;e<t;e++)Ee(le[e])}),updateElem:Ee}),ze=function(){ze.i||(ze.i=!0,me._(),fe._())};return ue={cfg:z,autoSizer:me,loader:fe,init:ze,uP:N,aC:E,rC:_,hC:A,fire:M,gW:W,rAF:T}}function ye(){var e=o;for(o=t.length?s:t,i=!(n=!0);e.length;)e.shift()();n=!1}function he(e,t){n&&!t?e.apply(this,arguments):(o.push(e),i||(i=!0,(m.hidden?u:f)(ye)))}function ve(e){ee--,e&&!(ee<0)&&e.target||(ee=0)}function ge(e){return(q=null==q?"hidden"==x(m.body,"visibility"):q)||"hidden"!=x(e.parentNode,"visibility")&&"hidden"!=x(e,"visibility")}function pe(){var e,t,n,a,i,s,o,r,l,c,d,u,f=ue.elements;if((R=z.loadMode)&&ee<8&&(e=f.length)){for(t=0,te++,c=!z.expand||z.expand<1?500<y.clientHeight&&500<y.clientWidth?500:370:z.expand,d=(ue._defEx=c)*z.expFactor,u=z.hFac,q=null,Z<d&&ee<1&&2<te&&2<R&&!m.hidden?(Z=d,te=0):Z=1<R&&1<te&&ee<6?c:0;t<e;t++)if(f[t]&&!f[t]._lazyRace)if(Y)if(l!==(s=!(r=f[t][h]("data-expand"))||!(s=+r)?Z:s)&&(D=innerWidth+s*u,H=innerHeight+s,o=-1*s,l=s),n=f[t].getBoundingClientRect(),(I=n.bottom)>=o&&(O=n.top)<=H&&($=n.right)>=o*u&&(P=n.left)<=D&&(I||$||P||O)&&(z.loadHidden||ge(f[t]))&&(S&&ee<3&&!r&&(R<3||te<4)||function(e,t){var n,a=e,i=ge(e);for(O-=t,I+=t,P-=t,$+=t;i&&(a=a.offsetParent)&&a!=m.body&&a!=y;)(i=0<(x(a,"opacity")||1))&&"visible"!=x(a,"overflow")&&(n=a.getBoundingClientRect(),i=$>n.left&&P<n.right&&I>n.top-1&&O<n.bottom+1);return i}(f[t],s))){if(oe(f[t]),i=!0,9<ee)break}else!i&&S&&!a&&ee<4&&te<4&&2<R&&(F[0]||z.preloadAfterLoad)&&(F[0]||!r&&(I||$||P||O||"auto"!=f[t][h](z.sizesAttr)))&&(a=F[0]||f[t]);else oe(f[t]);a&&!i&&oe(a)}}function Ce(){G=!1,J=r.now(),j()}function be(e){var t=e.target;t._lazyCache?delete t._lazyCache:(ve(e),E(t,z.loadedClass),_(t,z.loadingClass),w(t,ie),M(t,"lazyloaded"))}function Ae(e){var t,n=e[h](z.srcsetAttr);(t=z.customMedia[e[h]("data-media")||e[h]("media")])&&e.setAttribute("media",t),n&&e.setAttribute("srcset",n)}function Ee(e,t,n){var a=e.parentNode;a&&(n=W(e,a,n),(t=M(e,"lazybeforesizes",{width:n,dataAttr:!!t})).defaultPrevented||(n=t.detail.width)&&n!==e._lazysizesWidth&&ce(e,a,t,n))}});lazySizes.init();</script></html>