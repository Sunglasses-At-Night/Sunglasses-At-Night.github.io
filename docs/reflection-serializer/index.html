<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="0x00000000.dev">





<title>Writing a JSON serializer using C++ Reflection | 0x00000000 Blog</title>



    <link rel="icon" href="/favicon.ico">



<link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
<link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
<link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"><style>
.dark-color-main {
    background-color: #121212;
}
</style><style>.no-js img.lazyload {
    display: none;
}img[data-sizes="auto"] {
    display: block;
    width: 100%;
}</style></head>

<body class="dark-color-main text-light">
    <br><br><br><br>
    <div class="wrapper">
        <header>
    <style>
        .navbar {
            /* position: fixed; */
            top: 0;
            width: 100%;
            height: 6%;
            padding-top: 0px;
            padding-bottom: 0px;
            background: #5755d9;
            z-index: 5;
            position: absolute;
        }

        @media screen and (min-width: 170px) {
            .navbar {
                display: flex;
            }

            .main {
                padding-top: 0pt;
            }
        }
    </style>
    <!-- NAV -->
    <header class="navbar">
        <section class="navbar-section">
            <!-- <div class="navbar-header header-logo"><a href="/">0x00000000 Blog</a></div> -->
        </section>
        <section class="navbar-center">
            <a class="btn btn-link text-light" href="/">Home</a>
            
                <a class="btn btn-link text-light" href="/archives">
                    Posts
                </a>
                
                <a class="btn btn-link text-light" href="/tags">
                    Tags
                </a>
                
        </section>
        <section class="navbar-section">
            <!-- <input id="switch_default" type="checkbox" class="switch_default"> -->
            <!-- <label for="switch_default" class="toggleBtn"></label> -->
        </section>
    </header>
</header>
<br><br>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
        <article class="post-wrap columns">
            <style>
                .div-only-mobile {
                    display: none;
                }

                .div-no-mobile {
                    display: block;
                }

                @media screen and (max-width: 1280px) {
                    .div-no-mobile {
                        display: none
                    }

                    .div-only-mobile {
                        display: block;
                    }
                }

                ul {
                    list-style-position: outside;
                }

                ol ol, ol ul, ul ol, ul ul {
                    margin: 0 0 0 0;
                }

                .text-light {
                    color: #e8e8e8!important;
                }

            </style>
            <div class="column col-xl-2"></div>
            <div class="column col-8 col-xl-12">
                <header class="post-header">
                    <h1 class="post-title">
                        Writing a JSON serializer using C++ Reflection
                    </h1>
                    
                        <div class="post-meta">
                            
                                <a class="text-light">Author: </a><a class="text-gray">
                                        Roland Shum
                                    </a>
                                
                                    <br>
                                    
                                        <a class="text-light">Date: </a><a class="text-gray">
                                                October 17, 2021
                                            </a>
                                        
                                <br>
                                <a class="text-light">Views: <script>document.write('<img src="//counter.websiteout.net/compte.php?S='+encodeURI(window.location.href)+'&C=9&D=0&N=0&M=0" alt="" border="0"/>');</script></a>
                        </div>
                        
                </header>
                <div class="post-content">
                    <h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><style>
.child{
    width:  60%;
}

@media screen and (max-width: 600px) {
  .child{
      width:  100%;
  }
}

.desktop-70-mobile-100{
    width:  70%;
}

@media screen and (max-width: 600px) {
  .desktop-70-mobile-100{
      width:  100%;
  }
}

.desktop-50-mobile-100{
    width:  50%;
}

@media screen and (max-width: 600px) {
  .desktop-50-mobile-100{
      width:  100%;
  }
}
</style>

<script>
$( document ).ready(function() {
  var cw = $('.child').width();
  $('.child').css({
      'height': cw + 'px'
  });
});
</script>

<h2 id="About-the-Author"><a href="#About-the-Author" class="headerlink" title="About the Author"></a>About the Author</h2><p>Roland Shum: Engine Developer</p>
<p>I am a Computer Science students at the DigiPen Institute of Technology, and have been working on game projects together for several years.</p>
<p><a target="_blank" rel="noopener" href="https://store.steampowered.com/search/?developer=Handshake%20Firm">Here</a> are some games I have worked on and published:</p>
<p><noscript><img src="/images/TerrainGeneration/ArcApellago.jpg" alt="ArcApellago"></noscript><img src="/images/LazyLoad.png" alt="ArcApellago" data-src="/images/TerrainGeneration/ArcApellago.jpg" class="lazyload"><br><noscript><img src="/images/TerrainGeneration/DeltaBlade2700.jpg" alt="DeltaBlade2700"></noscript><img src="/images/LazyLoad.png" alt="DeltaBlade2700" data-src="/images/TerrainGeneration/DeltaBlade2700.jpg" class="lazyload"></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Arc Apellago was a year-long game project that I worked together with several members of the team. Its an action platformer with a focus on dash-attack and jumping around to get to the end of the level. We developed a C++ custom engine from scatch, integrating our own libraries and then using that engine to develop the game.</p>
<p>Parts of the engine I worked on:</p>
<ul>
<li>Integration of <a target="_blank" rel="noopener" href="https://www.rttr.org/">Real Time Type Reflection (RTTR)</a></li>
<li><strong>Integration of <a target="_blank" rel="noopener" href="https://github.com/nlohmann/json">JSON for Modern C++</a> serialization using RTTR</strong></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui">ImGui</a> Engine GUI generation using RTTR</li>
<li>Designing archetypes for entities</li>
</ul>
<p>Parts of the game I worked on:</p>
<ul>
<li>Visual effects</li>
<li>Post processing effects</li>
<li>Player feedback</li>
</ul>
<p>And things outside of the engine such as:</p>
<ul>
<li>Configuring a student Azure VM to build our game on every push<ul>
<li>CI / CD</li>
</ul>
</li>
<li>Configuring a student Amazon Web Service (AWS) VM to automatically sync the school’s git repo to our internal private git server</li>
<li>Tracked and scoped technical tasks as part of co-producer work and making sure everyone’s workflow was smooth</li>
</ul>
<p>This blog will focus on using <strong>reflection for json serialization</strong>. While I used RTTR as a reflection library, I believe the high level concept covers other reflection libraries. During the course of my work, I realized that there aren’t many resources on this topic. I will be describing a simplified version of what I did and omitting long talks into the many mistakes I’ve made; I’ll only point out my mistakes from time to time. <strong>I hope this will be useful for people trying to thread on the same path I did.</strong> </p>
<h2 id="What-are-you-talking-about"><a href="#What-are-you-talking-about" class="headerlink" title="What are you talking about?"></a>What are you talking about?</h2><p>So essentially what I did was</p>
<ol>
<li>Integrate reflection library (RTTR)</li>
<li>Integrate JSON reading and writing data</li>
<li><strong>For serialization</strong><ul>
<li><strong>Use reflection to generate the JSON object</strong></li>
<li><strong>Use JSON object and JSON library to write to file</strong></li>
</ul>
</li>
<li>For deserialization<ul>
<li>Read JSON from file to read JSON object</li>
<li>Use JSON object to read achetypes</li>
</ul>
</li>
<li>Use reflection data to generate editor GUIs for modifying values at runtime</li>
</ol>
<p>This blog will be focused on json serialization with reflection.</p>
<h3 id="What-is-reflection"><a href="#What-is-reflection" class="headerlink" title="What is reflection"></a>What is reflection</h3><p>Reflection is the ability to inspect, modify, and call methods at runtime. Imagine being able to inspect your type of object, and getting information about it.</p>
<p><noscript><img src="/images/Reflection-Serializer/CPPStruct.png" alt="MyStruct"></noscript><img src="/images/LazyLoad.png" alt="MyStruct" data-src="/images/Reflection-Serializer/CPPStruct.png" class="lazyload"></p>
<p>Essentially, you can get a MyStructType that describes “Hey I have a string name, an int data, a float bigNumber, and two methods. My name is ‘MyStruct’”.</p>
<h3 id="Why-did-you-need-reflection"><a href="#Why-did-you-need-reflection" class="headerlink" title="Why did you need reflection?"></a>Why did you need reflection?</h3><p>During the course of my research on serialization, I realized that there are only two ways to implement the system such that it was extendable and scalable.</p>
<table>
<thead>
<tr>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody><tr>
<td>Easy to understand (part of the language)</td>
<td>Cache miss on virtual functions (irrelevant on hindsight)</td>
</tr>
<tr>
<td>Easy to implement</td>
<td>Each class needs to define how it serializes</td>
</tr>
</tbody></table>
<p>Unfortunately, there is no third party solution that merges both RTTR and Json for Modern C++ libraries together. I had the choice of writing a reflection system, but I chose to use these third party libraries because I wanted to start the game iteration process as fast as possible.</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"MyStruct"</span> : {</span><br><span class="line">	<span class="attr">"name"</span> : <span class="string">"Instance Name"</span>,</span><br><span class="line">	<span class="attr">"data"</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="attr">"bigNumber"</span> : <span class="number">2.0</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h1 id="Goals-and-Constraints"><a href="#Goals-and-Constraints" class="headerlink" title="Goals and Constraints"></a>Goals and Constraints</h1><p>For the serializer to function, I constructed the system with several things in mind.</p>
<ul>
<li>Entity archetype saving and loading to Json</li>
<li>Abstracted from gameplay programmers<ul>
<li>Scripts don’t have to care about serializing</li>
</ul>
</li>
<li>Json file is readable to humans<ul>
<li>Designer can modify from json file</li>
</ul>
</li>
</ul>
<blockquote>
<p>Learning point:<br>The above seems good right? This was actually a <strong>bad</strong> set of goals. One major thing I overlooked was <strong>saving and loading from a scene</strong>. I also screwed up thinking that the <strong>designer modifying from the json file</strong> is a good thing. You want a tool for that instead.</p>
</blockquote>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>I started working on the json integration first as I wanted to fullfill the Course’s requirement on serialization first, and then do the reflection and GUI as an add on.</p>
<blockquote>
<p>Learning point: In hindsight, while in the short term this was the right decision,the long term was a bad one. Anyone can see once laid out that I should have worked with RTTR first, and then wrote the serializer and gui generator with it as a dependancy. Because of this mistake, I was straddled with legacy code that I had to write around.</p>
</blockquote>
<h2 id="Serializer-1-0"><a href="#Serializer-1-0" class="headerlink" title="Serializer 1.0"></a>Serializer 1.0</h2><p>The following is the diagram describing the serializer.</p>
<p><noscript><img src="/images/Reflection-Serializer/serializermap.png" alt="Mind map of serializer"></noscript><img src="/images/LazyLoad.png" alt="Mind map of serializer" data-src="/images/Reflection-Serializer/serializermap.png" class="lazyload"></p>
<p>At 1.0, the goal was to get serialization working ASAP and getting past the grading requirments for it. I used the simplest method I know.</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sample object</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector3</span>{</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> JSON <span class="title">Serialize</span><span class="params">(<span class="keyword">const</span> Vector3&amp; vec)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        JSON j;</span><br><span class="line">        j[<span class="string">"x"</span>] = vec.x;</span><br><span class="line">        j[<span class="string">"y"</span>] = vec.y;</span><br><span class="line">        j[<span class="string">"z"</span>] = vec.z;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Vector3 <span class="title">Deserialize</span><span class="params">(JSON&amp; json)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Vector3 vec;</span><br><span class="line">        vec.x = json[<span class="string">"x"</span>];</span><br><span class="line">        vec.y = json[<span class="string">"y"</span>];</span><br><span class="line">        vec.z = json[<span class="string">"z"</span>];</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Serializer</span>{</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">JSON <span class="title">SerializeToJSON</span><span class="params">(<span class="keyword">const</span> T&amp; obj)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> T::Serialize(obj);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">T <span class="title">DeserializeFromJSON</span><span class="params">(JSON&amp; json)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> T::Deserialize(json);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// somewhere in code</span></span><br><span class="line">Vector3 dir = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line">JSON j = Serializer::SerializeToJSON(dir);</span><br><span class="line">save_to_file(j, <span class="string">"dir.json"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>There were mainly two ways I saw to go with this</p>
<ol>
<li>Use a template like what I am doing and call Serialize(). If T doesn’t have this method compilation will fail.</li>
<li>All types inherit ISerializble, and then use polymorphism.</li>
</ol>
<p>I went with option 1) because we were using glm::vec3 types and did not want to write an abstraction layer over them. Virtual functions also cause a cache miss, so I didn’t want to lose out on performance.</p>
<blockquote>
<p>Learning Point: The cache miss point was totally irrelevant. It would never have mattered since the perf I saved was so small. Furthermore, a bunch of these small code and legacy Json files became a massive headache later on development when I refused to just delete them. I should have called a team meeting and insist on removing the legacy code and data instead of putting two different architechture types together</p>
</blockquote>
<blockquote>
<p>Pondering Point: Should I have written an abstraction over glm (math library)? Common practice lean towards writing abstractions over every library you import, but a lot of glm functions only work because they expect glm types. Writing our own abstraction just meant writing boilerplate code over the glm ones, and that seemed like a waste of time since we don’t plan on using another math library.</p>
</blockquote>
<h2 id="Serializer-2-0"><a href="#Serializer-2-0" class="headerlink" title="Serializer 2.0"></a>Serializer 2.0</h2><p>You may notice that the serializer 1.0 <em>does nothing</em>. It only gives ensures common interface of T (to have a method called Serialize()).<br><strong>Currently the object is responsibly for <em>how</em> it serializes itself, what we want is for the <em>serializer</em> to be responsible for that.</strong> If we had 100 objects, that means we would have to write the specific serialization code for 100+ objects. But with one generic serializer we would theoretically save up to 1/3 of the time writing serialization.</p>
<p>What we currently have:<br><noscript><img src="/images/Reflection-Serializer/serializer_before.png" alt="Serializer 1.0"></noscript><img src="/images/LazyLoad.png" alt="Serializer 1.0" data-src="/images/Reflection-Serializer/serializer_before.png" class="lazyload"></p>
<p>But what we really want is:<br><noscript><img src="/images/Reflection-Serializer/serialize-after.png" alt="Serializer 2.0"></noscript><img src="/images/LazyLoad.png" alt="Serializer 2.0" data-src="/images/Reflection-Serializer/serialize-after.png" class="lazyload"></p>
<p>I’ll now walk through a simplified version of my Serializer 2.0 and explain the thought process behind it. </p>
<p>There are 3 main ideas crucial to bringing the initial algorithm together.</p>
<ol>
<li>Deconstructing a user-defined data type</li>
<li>Understanding how things should be on the JSON side</li>
<li>Dealing with pointers, data structures, and containers</li>
</ol>
<p>And after that I had to modify the algorithm to work with RTTR library. Lets drive right in.</p>
<h3 id="Deconstructing-a-user-defined-data-type"><a href="#Deconstructing-a-user-defined-data-type" class="headerlink" title="Deconstructing a user-defined data type"></a>Deconstructing a user-defined data type</h3><p>Every type in C++ can be deconstructed to its fundamental types of int, char, pointer, etc.</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InnerClass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">float</span> floatdata;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OuterClass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    InnerClass innerClass;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * c_string;</span><br><span class="line">}</span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Outerclass can be deconstructed into</span></span><br><span class="line">OuterClass</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">float</span> floatdata;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c_string;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>So the plan is to deconstruct a type <em>as much as possible</em>. Hence the general algorithm I used is</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Serialize</span>(<span class="params">obj</span>):</span></span><br><span class="line">    <span class="keyword">if</span> obj <span class="keyword">is</span> a basic type</span><br><span class="line">        serialize data <span class="keyword">as</span> one of the basic types</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> each property on obj:</span><br><span class="line">            Serialize(property)</span><br></pre></td></tr></tbody></table></figure>

<p>Seems simple for now! Notice that I passed over what it means to be a basic type. While we understand in C++ those data types, what are the fundamental basic types in JSON? </p>
<h3 id="Examining-the-JSON-side"><a href="#Examining-the-JSON-side" class="headerlink" title="Examining the JSON side"></a>Examining the JSON side</h3><p>Json has five data types</p>
<ol>
<li>Number<ul>
<li>No distinction between floats and ints and unsigned etc</li>
</ul>
</li>
<li>String</li>
<li>Boolean</li>
<li>Array</li>
<li>Object<ul>
<li>Collection of name-value pairs</li>
</ul>
</li>
<li>null<ul>
<li>empty</li>
</ul>
</li>
</ol>
<p>Given these data types, it makes sense to store C++ user defined types as objects, and they would in turn recursively store things until its either </p>
<ol>
<li>A number</li>
<li>A string</li>
<li>A boolean</li>
<li>Or an array</li>
</ol>
<p>I used the property name as the key, and the object itself as the value. This seemed most intuitive. You might notice that ‘A number’ doesn’t describe the wide range of data types that can represent a number in C++. Thankfully, most JSON libraries can handle this. Thus when serialized OuterClass would look like </p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"OuterClass"</span> : {</span><br><span class="line">        <span class="attr">"innerClass"</span> : {</span><br><span class="line">            <span class="attr">"data"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"floatdata"</span>: <span class="number">0.0</span></span><br><span class="line">        },</span><br><span class="line">        <span class="attr">"c_string"</span> : <span class="string">"cstring"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>Learning Point: One of the goals were to have the designer change the data from the json file. Thus I wanted the json file to be “human readable”. This in turn led to some very poor choices like serializing Vec3 as an array of 3 floats etc. These edge cases piled up instantly and made my deseriailization work a mess. If I were to do this again I would just try to write the base code as intuitively (for a programmer) as possible, and then write a tool to modify the json file.</p>
</blockquote>
<blockquote>
<p>Pondering Point: What if I wrote a tool that converted older version jsons to newer ones? Thinking back, this wasn’t much of a choice since there are around 4 json files and its probably not worth it.</p>
</blockquote>
<p>Take note that this was the <em>final</em> output that I have decided on. During the course of developement, there were three different outputs that I tried, and I finally settled on keeping the algorithm clean instead.</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 2</span></span><br><span class="line"><span class="comment"># Kickoff function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Serialize</span>(<span class="params">obj, name</span>):</span></span><br><span class="line">    JSON jsonObj</span><br><span class="line">    SerializeRecur(obj, jsonObj[name])</span><br><span class="line">    <span class="keyword">return</span> jsonObj</span><br><span class="line"></span><br><span class="line"><span class="comment"># Arg0: object we want to serialize</span></span><br><span class="line"><span class="comment"># Arg1: json object to add onto</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SerializeRecur</span>(<span class="params">obj, jsonObj</span>):</span></span><br><span class="line">    <span class="keyword">if</span> obj <span class="keyword">is</span> a basic type</span><br><span class="line">        SerializeBasicType(obj, jsonObj[obj.name()])</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> each property on obj:</span><br><span class="line">            SerializeRecur(property, jsonObj[property.name()])</span><br><span class="line"></span><br><span class="line">// Possible usage</span><br><span class="line">Outerclass outerClass</span><br><span class="line">Serialize(outerClass, <span class="string">"OuterClass"</span>) </span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>The mentioned three different versions of output became a long lasting pain. I could never easily refactor my code without totally busting the previous versions. In hindsight, I should have gotten rid of them ASAP and swapped to the newer versions. Also, I should have given my Json files a version number to keep track of which version of the loader I was using. That way I could have kept my code clean instead of integrating them all into Frankenstien. </p>
</blockquote>
<h3 id="Dealing-with-C-’ness’-issues"><a href="#Dealing-with-C-’ness’-issues" class="headerlink" title="Dealing with C++’ness’ issues"></a>Dealing with C++’ness’ issues</h3><p>I’ve explained the very high level general algorithm of deconstructing a C++ type into its base type, and how I translated that into JSON file. When it comes to the dirt though, there are lots of weird C++ issues to deal with, and I’m glad I used RTTR as a library instead of writing my own reflection system to deal with them.</p>
<p>This part really consists of deconstructing what it means to be a <em>fundamental type in the context of serialization</em>. </p>
<h4 id="Dealing-with-polymorphism"><a href="#Dealing-with-polymorphism" class="headerlink" title="Dealing with polymorphism"></a>Dealing with polymorphism</h4><p>Heres an example of some very reasonable code that would break our current algorithm.</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> {</span> RTTR_ENABLE() };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Middle</span> :</span> Base { RTTR_ENABLE(Base) };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Middle { RTTR_ENABLE(Middle) };</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> {</span> Base* bar = <span class="literal">nullptr</span>;};</span><br><span class="line"></span><br><span class="line">Foo foo;</span><br><span class="line">Derived derived;</span><br><span class="line"></span><br><span class="line">foo.bar = &amp;derived;</span><br><span class="line"><span class="comment">// How do we serialize Derived when we have a pointer to Bar?</span></span><br></pre></td></tr></tbody></table></figure>
<p>Polymorphism! And pointers! Pointers are a base data type, how do we deal with it? On the topic of pointers, what if it was a <em>shared</em> pointer? </p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> {</span><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Derived&gt; ptr;}</span><br><span class="line"></span><br><span class="line">Foo foo;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Derived&gt; instance = <span class="built_in">std</span>::make_shared&lt;Derived&gt;();</span><br><span class="line">foo.ptr = instance;</span><br><span class="line"><span class="comment">// How do we deal with this??</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>At the start of the project, we were avoiding shared pointers because we were not doing multithreading and did not think we would need to manage our objects. This turns out to be completely false assumption when we realized our game code had behavior that references other behaviors. This caching became a classic dangling pointer problem. We only noticed this problem a quater of the way in the project, and decided to convert to smart pointers rather then deal with implementing some wrapper that acheived the same thing but specific to our engine. There was also a discussion about getting all the references every frame, but that was thrown out once we realized some behaviors <em>needed</em> references, like AIs need to know player and the search isn’t cheap.</p>
</blockquote>
<p>So lets revisit our high level algorithm, and modify it. We need to deal with getting, as RTTR defines it, the <em>raw type</em> of our object. A raw type is a type <em>without any qualifiers</em> (const, volatile, etc) nor any pointer.<br>After that, we need to detect if it is a shared_ptr, or something that wraps a value. Luckily, RTTR provides <a target="_blank" rel="noopener" href="https://www.rttr.org/doc/master/classrttr_1_1type.html#ad17345a59c8e3cc8a754eb4ec124581e">functionality</a> that detects if a type is a wrapper type. </p>
<p>As for getting the derived type of a pointer, RTTR deals with that for us with <a target="_blank" rel="noopener" href="https://www.rttr.org/doc/master/classrttr_1_1instance.html#ab30381b954f8d8abc2da9c5162fb130d">get_derived_type()</a>.</p>
<p>I’ll also swap the pseudocode for checking base type for an rttr function <a target="_blank" rel="noopener" href="https://www.rttr.org/doc/master/classrttr_1_1type.html#a8bd100682c9b846f6da1c5c9fb96f8c6">is_class()</a>.</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 3</span></span><br><span class="line"><span class="comment"># Here I'm working in psuedo code with RTTR API</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kickstart function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Serialize</span>(<span class="params">obj, name</span>):</span></span><br><span class="line">    JSON jsonObj</span><br><span class="line">    SerializeRecur(obj, jsonObj[name])</span><br><span class="line">    <span class="keyword">return</span> jsonObj</span><br><span class="line"></span><br><span class="line"><span class="comment"># Arg0: object we want to serialize</span></span><br><span class="line"><span class="comment"># Arg1: json object to add onto</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SerializeRecur</span>(<span class="params">obj, jsonObj</span>):</span></span><br><span class="line">    <span class="comment"># If object is a fundemental C++ type, we'll go straight to writing it</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> obj.is_class()</span><br><span class="line">        SerializeBasic(obj, jsonObj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># Get the type of the object if it is a wrapper</span></span><br><span class="line">        <span class="keyword">if</span> obj.type.get_raw_type().is_wrapper()</span><br><span class="line">            localObj = obj.get_wrapped_instance()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            localObj = obj</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Deal with polymorphism issues by going to the derived class</span></span><br><span class="line">        derivedType = localObj.get_derived_type()</span><br><span class="line">        <span class="comment"># Get property list from the derived type</span></span><br><span class="line">        var property_list = derivedType.get_properties()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iterate through the property list</span></span><br><span class="line">        <span class="keyword">for</span> var property <span class="keyword">in</span> property_list</span><br><span class="line">            <span class="comment"># Get the value of the property</span></span><br><span class="line">            rttr::variant property_value = property.get_value(localObj)</span><br><span class="line">            <span class="comment"># Keep serializing them based on property name</span></span><br><span class="line">            SerializeRecur(property_value, jsonObj[property.name()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Possible usage</span><br><span class="line">Outerclass outerClass</span><br><span class="line">Serialize(outerClass, <span class="string">"OuterClass"</span>) </span><br></pre></td></tr></tbody></table></figure>

<h3 id="Dealing-with-arrays-and-data-structures"><a href="#Dealing-with-arrays-and-data-structures" class="headerlink" title="Dealing with arrays and data structures"></a>Dealing with arrays and data structures</h3><p>Some very useful data structures that we want to serialize are arrays, vectors, and C++ maps (ordered or unordered). Thankfully they have pretty 1 : 1 conversions to JSON data.</p>
<ul>
<li>C++ Arrays &lt;-&gt; JSON Arrays</li>
<li>C++ Vectors &lt;-&gt; JSON Arrays</li>
<li>C++ Maps &lt;-&gt; JSON Objects</li>
</ul>
<p>Even better, RTTR has two methods of identifying containers that cover your STL data containers. <a target="_blank" rel="noopener" href="https://www.rttr.org/doc/master/classrttr_1_1variant.html#aabe380968e1d9fcd27a2f3e77728b197">is_associative_container()</a> and <a target="_blank" rel="noopener" href="https://www.rttr.org/doc/master/classrttr_1_1variant.html#a2d584cf950f15d1a52469b5f042488a3">is_sequential_container()</a>. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Associative_containers">Associative containers</a> are like maps, you map one thing to another. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sequence_container_(C%2B%2B)">Sequential containers</a> are containers with memories laid out contigiously, like vectors and arrays. According to wikipedia, the current C++ data structures are below.</p>
<ul>
<li>Sequential Container<ul>
<li>Array</li>
<li>Vector</li>
<li>List</li>
<li>Forward_list</li>
<li>Deque</li>
</ul>
</li>
<li>Associative Container<ul>
<li>Set</li>
<li>Map</li>
<li>Multiset</li>
<li>Multismap</li>
</ul>
</li>
</ul>
<p>And so we will have</p>
<ul>
<li>C++ Array &lt;-&gt; Sequential Container &lt;-&gt; JSON Array</li>
<li>C++ Vector &lt;-&gt; Sequential Container &lt;-&gt; JSON Array</li>
<li>C++ Maps &lt;-&gt; Associative Container &lt;-&gt; JSON Objects</li>
<li>C++ Hash Maps (Unordered_*) &lt;-&gt; Associative Container &lt;-&gt; JSON Objects</li>
</ul>
<p>Which simplifies to</p>
<ul>
<li>Sequential Container &lt;-&gt; JSON Array</li>
<li>Associative Container &lt;-&gt; JSON Objects</li>
</ul>
<p>So we will identify if the type of the object is sequential or associative, and if they are we will handle them.</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 4</span></span><br><span class="line"><span class="comment"># Here I'm working in psuedo code with RTTR API</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kickstart function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Serialize</span>(<span class="params">obj, name</span>):</span></span><br><span class="line">    JSON jsonObj</span><br><span class="line">    Serialize(obj, jsonObj[name])</span><br><span class="line">    <span class="keyword">return</span> jsonObj</span><br><span class="line"></span><br><span class="line"><span class="comment"># Arg0: object we want to serialize</span></span><br><span class="line"><span class="comment"># Arg1: json object to add onto</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SerializeRecur</span>(<span class="params">obj, jsonObj</span>):</span></span><br><span class="line">    <span class="comment"># If object is a fundemental C++ type, we'll go straight to writing it</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> obj.is_class()</span><br><span class="line">        SerializeBasic(obj, jsonObj)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> obj.is_associative_container()</span><br><span class="line">        WriteArray(obj, jsonObj)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> obj.is_sequential_container()</span><br><span class="line">        WriteAssociative(obj, jsonObj)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment"># Get the type of the object if it is a wrapper</span></span><br><span class="line">        <span class="keyword">if</span> obj.type.get_raw_type().is_wrapper()</span><br><span class="line">            localObj = obj.get_wrapped_instance()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            localObj = obj</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Deal with pointer issues by going to the derived class</span></span><br><span class="line">        derivedType = localObj.get_derived_type()</span><br><span class="line">        <span class="comment"># Get property list from the derived type</span></span><br><span class="line">        var property_list = derivedType.get_properties()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Iterate through the property list</span></span><br><span class="line">        <span class="keyword">for</span> var property <span class="keyword">in</span> property_list</span><br><span class="line">            <span class="comment"># Get the value of the property</span></span><br><span class="line">            rttr::variant property_value = property.get_value(localObj)</span><br><span class="line">            <span class="comment"># Keep serializing them based on property name</span></span><br><span class="line">            SerializeRecur(property_value, jsonObj[property.name()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Possible usage</span><br><span class="line">Outerclass outerClass</span><br><span class="line">Serialize(outerClass, <span class="string">"OuterClass"</span>) </span><br></pre></td></tr></tbody></table></figure>
<h4 id="Sequential-Container-Seriailization"><a href="#Sequential-Container-Seriailization" class="headerlink" title="Sequential Container Seriailization"></a>Sequential Container Seriailization</h4><p>After detecting whether it is an associative or a sequential container, we have to decide how to serialize it. We’ll start with sequential since thats the simplest. Since sequential maps to Json arrays 1 to 1, this was pretty simple.</p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WriteArray</span>(<span class="params">obj, jsonObj</span>):</span></span><br><span class="line">    jsonObj.WriteJsonArray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each item <span class="keyword">in</span> obj, <span class="keyword">and</span> counter start <span class="keyword">from</span> <span class="number">0</span>:</span><br><span class="line">        WriteVariant(item, writer[counter])</span><br><span class="line">        counter += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"array"</span> : [</span><br><span class="line">        a,</span><br><span class="line">        b,</span><br><span class="line">        c</span><br><span class="line">    ],</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Associative-Container"><a href="#Associative-Container" class="headerlink" title="Associative Container"></a>Associative Container</h4><p>This one is a <em>bit</em> more complicated. We want to store both key and value, and we know our object will have multiple key and value. So lets use a json array to indicate all the key-pair values as json objects. </p>
<figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WriteAssociative</span>(<span class="params">obj, jsonObj</span>):</span></span><br><span class="line">    jsonObj.WriteJsonArray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each item <span class="keyword">in</span> obj, <span class="keyword">and</span> counter start <span class="keyword">from</span> <span class="number">0</span>:</span><br><span class="line">        WriteVariant(item.first, writer[i][<span class="string">"Key"</span>])</span><br><span class="line">        WriteVariant(item.second, writer[i][<span class="string">"Value"</span>])</span><br></pre></td></tr></tbody></table></figure>
<p>and we’re expecting something like this.</p>
<figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">"dictionary" : [</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"red"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: {</span><br><span class="line">            <span class="attr">"x"</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">"y"</span>: <span class="number">6</span></span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">        <span class="attr">"key"</span>: <span class="string">"green"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: {</span><br><span class="line">            <span class="attr">"x"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"y"</span>: <span class="number">2</span></span><br><span class="line">        }</span><br><span class="line">    },</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>


<h3 id="Wrangling-RTTR"><a href="#Wrangling-RTTR" class="headerlink" title="Wrangling RTTR"></a>Wrangling RTTR</h3><p>It was hard working with a library where I had no idea how it internally works. Let me explain some of the main concepts of RTTR that I had trouble understanding at first. This section will detail mainly how I coded the above psuedocodes in a C++ manner.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.rttr.org/doc/master/classrttr_1_1instance.html">Instance</a><ul>
<li>Holds a reference to the given object.</li>
<li>Think of it as a std::any&lt;T&amp;&gt;</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.rttr.org/doc/master/register_variant_page.html">Variant</a><ul>
<li>Return value for properties and methods</li>
<li>Content is <em><strong>copied</strong></em> over to new instance of content</li>
<li>Think of it as a std::any<t></t></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.rttr.org/doc/master/register_properties_page.html">Properties</a><ul>
<li>Pretty straight forward</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.rttr.org/doc/master/register_policies_page.html">Policies</a><ul>
<li>Control how RTTR creates your object</li>
<li>This matters when the code starts running too slow</li>
</ul>
</li>
</ul>
<blockquote>
<p>One of the weirder things about the RTTR library is how <em>different</em> and how <em>little</em> an instance provides over a variant. I would expect an instance to have just as much to offer as a variant in terms of interface. It seems strange that I would need to copy an object anytime I wanted to query more information on it.</p>
</blockquote>
<blockquote>
<p>Also this sets a constraint that you need to use assignment operators for whatever you’re serializing. And default constructors for compatibility with sequential and associative containers.</p>
</blockquote>
<p>With those in mind, lets get to writing actual C++ code and we’ll start with registering our class with RTTR</p>
<h4 id="Registration"><a href="#Registration" class="headerlink" title="Registration"></a>Registration</h4><p>This part is pretty straightforward, do it in the CPP with a couple of macros from RTTR. Here, we register InnerClass with properties innerClass and c_string. After that we register InnerClass with data and floatdata.</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RTTR_REGISTRATION</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> rttr;</span><br><span class="line">	registration::class_&lt;InnerClass&gt;(<span class="string">"InnerClass"</span>)</span><br><span class="line">		.constructor&lt;&gt;()</span><br><span class="line">		(</span><br><span class="line">			rttr::policy::ctor::as_raw_ptr <span class="comment">// Construct as raw pointer instead of shared for simplicity's sake</span></span><br><span class="line">		)</span><br><span class="line">		.property(<span class="string">"data"</span>, &amp;InnerClass::data)</span><br><span class="line">		.property(<span class="string">"floatdata"</span>, &amp;InnerClass::floatdata)</span><br><span class="line">	;</span><br><span class="line"></span><br><span class="line">    registration::class_&lt;OuterClass&gt;(<span class="string">"OuterClass"</span>)</span><br><span class="line">		.constructor&lt;&gt;()</span><br><span class="line">		(</span><br><span class="line">			rttr::policy::ctor::as_raw_ptr <span class="comment">// Construct as raw pointer instead of shared for simplicity's sake</span></span><br><span class="line">		)</span><br><span class="line">		.property(<span class="string">"innerClass"</span>, &amp;OuterClass::innerClass)</span><br><span class="line">		.property(<span class="string">"c_string"</span>, &amp;OuterClass::c_string)</span><br><span class="line">	;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="Writing-the-serialization-code"><a href="#Writing-the-serialization-code" class="headerlink" title="Writing the serialization code"></a>Writing the serialization code</h4><p>Lets begin by taking in a name and a instance (reference) of the object.</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kickstart function</span></span><br><span class="line"><span class="function">JSON <span class="title">ToJson</span><span class="params">(rttr::instance obj, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    JSON writer;</span><br><span class="line">    ToJSonRecur(obj, writer[name]);</span><br><span class="line">    <span class="keyword">return</span> writer;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Improvements-to-fundemental-type-detection"><a href="#Improvements-to-fundemental-type-detection" class="headerlink" title="Improvements to fundemental type detection"></a>Improvements to fundemental type detection</h5><p>I was stuck here for a long time figuring out how wrangle the conversions between instances and variants and serialization. In the end, I implemented a function dedicated to writing variants, and then another function for writing basic types. Both of these work with a “white list”; that is if the function detects it cannot be serialized and return false.</p>
<p>Lets take a look at the recursive function from before.</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !Passing something that isn't supposed to be written as a Json Object will have issues</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToJsonRecur</span><span class="params">(rttr::instance obj, JSON&amp; writer)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// If we successfully serialized, it means its a fundamental type</span></span><br><span class="line">    <span class="keyword">if</span>(WriteFundamentalType(obj, writer))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    rttr::instance localObj;</span><br><span class="line">    <span class="comment">// Get the type of the object if it is a wrapper</span></span><br><span class="line">    <span class="keyword">if</span>(obj.get_type().get_raw_type().is_wrapper())</span><br><span class="line">        localObj = obj.get_wrapped_instance();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        localObj = obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the property list while dealing with polymorphism derived type</span></span><br><span class="line">    <span class="keyword">auto</span> prop_list = obj.get_derived_type().get_properties();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Iterate through the property list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> prop : prop_list)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Get the value of the property</span></span><br><span class="line">        rttr::variant prop_value = prop.get_value(obj);</span><br><span class="line">        <span class="keyword">if</span> (!prop_value)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// cannot serialize, because we cannot retrieve the value</span></span><br><span class="line">        <span class="comment">// Get the name of the property</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> name = prop.get_name();</span><br><span class="line">        <span class="comment">// Attempt to write the variant</span></span><br><span class="line">        <span class="keyword">if</span> (!VariantSerializer(prop_value, writer[name.data()]))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"cannot serialize property: "</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example use case</span></span><br><span class="line">OuterClass foo;</span><br><span class="line">JSON writer;</span><br><span class="line">ToJsonRecur(foo, <span class="string">"foo"</span>, writer);</span><br></pre></td></tr></tbody></table></figure>
<p>The biggest difference is the use of rttr::instance as the object. This was chosen for the simple interface given. For some weird reason I <strong>could not</strong> convert an instance to a variant. It might make more sense to pass in a variant in that sense since variants have more functionality, but its also a copy which can be expensive. </p>
<p>This choice removed the possibility of checking whether the instance is a fundamental type, and all the checking for the the maps before we split it up. This actually helped writing the code in a certain way because I could seperate the code more clearly from an RTTR perspective.</p>
<p>A second issue that came up was how to abstract the fundamental type seriailization detection out. In the end, I opted for a function that will attempt to serialize the object as a fundamental type, and if it fails it will return false. We will then test if it is any of the data containers, and then check how many properties the object has. If there it has  properties, then we can serialize it as a jsonObj.</p>
<p>So the plan is to deal with each RTTR abstraction at each level appropriately.<br><noscript><img src="/images/Reflection-Serializer/serialize_new_plan.png" alt="The new plan"></noscript><img src="/images/LazyLoad.png" alt="The new plan" data-src="/images/Reflection-Serializer/serialize_new_plan.png" class="lazyload"></p>
<p>And a fleshed out detail of the plan is on this image.   </p>
<p><noscript><img src="/images/Reflection-Serializer/serialize_detail.png" alt="The new plan with detail"></noscript><img src="/images/LazyLoad.png" alt="The new plan with detail" data-src="/images/Reflection-Serializer/serialize_detail.png" class="lazyload"></p>
<p>With the new algorithm, WriteVariant() is the crux of it all. It attempts to write the object, and if it can’t have several fallbacks, and at the end of it will either return true or fail. Failing means a case we haven’t dealt with yet(pointers for example).</p>
<p>Another side-effect of this version of the algorithm is that we can only kick off the serialization function if the object we’re passing in has properties. Meaning the type has to be a jsonObj. However, we can easily use WriteVariant() as the entry point if required.</p>
<blockquote>
<p>Learning Point: Typically, serialization code is paired with deserialization code. Hence the simpler your serialization code, the easier it will be to write your deserialization. For my engine code, I did my own serialization of many glm types, like glm::vec3, early on and this came back to haunt me as I had to keep creating edge cases for detecting a glm::vec3 in my deserialization code. Keep it simple, less things to worry about when writing deserialization.</p>
</blockquote>
<h4 id="C-code"><a href="#C-code" class="headerlink" title="C++ code"></a>C++ code</h4><p>Headed back to the code, lets show the changed toJsonRecur().</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toJsonRecursive</span><span class="params">(<span class="keyword">const</span> instance&amp; obj, json&amp; writer)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Dealing with wrapped objects</span></span><br><span class="line">    instance localObj;</span><br><span class="line">    <span class="keyword">if</span>(obj.get_type().get_raw_type().is_wrapper())</span><br><span class="line">        localObj = obj.get_wrapped_instance()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        localObj = obj;</span><br><span class="line">    <span class="comment">// Handling pointer polymorphism cases</span></span><br><span class="line">    <span class="keyword">auto</span> prop_list = obj2.get_derived_type().get_properties();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> prop : prop_list)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Retrieving value from property</span></span><br><span class="line">        variant prop_value = prop.get_value(obj2);</span><br><span class="line">        <span class="keyword">if</span> (!prop_value)</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// cannot serialize, because we cannot retrieve the value</span></span><br><span class="line">        <span class="comment">// Retrieve name of property</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> name = prop.get_name();</span><br><span class="line">        <span class="comment">// Serialize value of property using name</span></span><br><span class="line">        <span class="keyword">if</span> (!WriteVariant(prop_value, writer[name.data()]))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to serialize"</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Pretty much the same thing as the initial algorithm, except without all the checking. The checking has now moved to WriteVariant(), and here is the crux of the algorithm.</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WriteVariant</span><span class="params">(<span class="keyword">const</span> variant&amp; var, json&amp; writer)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Deal with wrapped type</span></span><br><span class="line">    variant localVar = var;</span><br><span class="line">    type varType = var.get_type();</span><br><span class="line">    <span class="keyword">if</span>(varType.is_wrapper())</span><br><span class="line">    {</span><br><span class="line">        varType = varType.get_wrapped_type();</span><br><span class="line">        localVar = localVar.extract_wrapped_value();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AttemptWriteFundementalType(varType, localVar, writer))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Successful write!</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// If its not a fundamental, is it a sequential?</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (var.is_sequential_container())</span><br><span class="line">    {</span><br><span class="line">        WriteArray(var.create_sequential_view(), writer);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Is it associative</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (var.is_associative_container())</span><br><span class="line">    {</span><br><span class="line">        WriteAssociativeContainer(var.create_associative_view(), writer);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Not a fundemental, or a container. Check if its an object</span></span><br><span class="line">        <span class="keyword">auto</span> child_props = varType.get_properties();</span><br><span class="line">        <span class="keyword">if</span> (!child_props.empty())</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// We have properties, thus we can be serialized as an object</span></span><br><span class="line">            toJsonRecursive(var, writer);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Assert</span></span><br><span class="line">            <span class="comment">// Some unknown type that is not a fundamental, has no properties, and is not a data structure</span></span><br><span class="line">            <span class="comment">// Probably some registration issue</span></span><br><span class="line">            <span class="comment">// Or its a pointer! I handled pointers in here my game code</span></span><br><span class="line">            assert(<span class="string">"Unknown RTTR serilization edge case that we haven't discovered"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>I moved the data container checking and writing of fundamental types here. Pretty self-explanatory stuff here. The only thing really worth mentioning is that I had to create a *_container view to view the container for WriteArray() and WriteAssociativeContainer().</p>
<p>Now lets take a look at the writing of fundamental types. One benefit here is that if we have more fundamental types to handle we can just put it in this function.</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AttemptWriteFundementalType</span><span class="params">(<span class="keyword">const</span> type&amp; t, <span class="keyword">const</span> variant&amp; var, json&amp; writer)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Json Number</span></span><br><span class="line">    <span class="keyword">if</span> (t.is_arithmetic())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (t == type::get&lt;<span class="keyword">bool</span>&gt;())</span><br><span class="line">            writer = var.to_bool();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == type::get&lt;<span class="keyword">char</span>&gt;())</span><br><span class="line">            writer = var.to_bool();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == type::get&lt;<span class="keyword">int</span>&gt;())</span><br><span class="line">            writer = var.to_int();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == type::get&lt;<span class="keyword">uint64_t</span>&gt;())</span><br><span class="line">            writer = var.to_uint64();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == type::get&lt;<span class="keyword">float</span>&gt;())</span><br><span class="line">            writer = var.to_double();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == type::get&lt;<span class="keyword">double</span>&gt;())</span><br><span class="line">            writer = var.to_double();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Enumeration as string</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.is_enumeration())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Attempt to serialize as string</span></span><br><span class="line">        <span class="keyword">auto</span> result = var.to_string(&amp;ok);</span><br><span class="line">        <span class="keyword">if</span> (ok)</span><br><span class="line">        {</span><br><span class="line">            writer = var.to_string();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Attempt to serialize as number</span></span><br><span class="line">            <span class="keyword">auto</span> value = var.to_uint64(&amp;ok);</span><br><span class="line">            <span class="keyword">if</span> (ok)</span><br><span class="line">                writer = <span class="keyword">uint64_t</span>(value);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                writer = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Strings!</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t == type::get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;())</span><br><span class="line">    {</span><br><span class="line">        writer = var.to_string();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not a fundamental type we know how to process</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Notice that this function doesn’t expect itself to handle all sorts of weird stuff like pointers, wrappers, or anything like that. Its very much a <strong>“If you have these I will serialize it. If not then good bye.”</strong></p>
<p>As for the associative and sequential containers:</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteArray</span><span class="params">(<span class="keyword">const</span> variant_sequential_view&amp; view, json&amp; writer)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Init array</span></span><br><span class="line">    writer = json::<span class="built_in">array</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : view)</span><br><span class="line">    {</span><br><span class="line">        WriteVariant(item, writer[i]);</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteAssociativeContainer</span><span class="params">(<span class="keyword">const</span> variant_associative_view&amp; view, json&amp; writer)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> string_view <span class="title">key_name</span><span class="params">(<span class="string">"key"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> string_view <span class="title">value_name</span><span class="params">(<span class="string">"value"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    writer = json::<span class="built_in">array</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Dealing with keys = values containers like sets</span></span><br><span class="line">    <span class="keyword">if</span> (view.is_key_only_type())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : view)</span><br><span class="line">        {</span><br><span class="line">            WriteVariant(item.first, writer[i]);</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : view)</span><br><span class="line">        {</span><br><span class="line">            WriteVariant(item.first, writer[i][key_name.data()]);</span><br><span class="line">            WriteVariant(item.second, writer[i][value_name.data()]);</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>You usually have to pair a serialization function with a deserialization function, but with this the base is setup such that it’ll be easier to do deserialization. If I have time, I’ll talk about how to deserialize from the json file to memory; its not particularly hard now that we have a good base setup.</p>
<p>A couple of things to note: this sample code doesn’t handle pointers or void pointers. Moreover, its not exactly efficient since we are calling a ton of copy constructors and assignment constructors. However, it does acheieve the goal of moving the burden of writing serialization to a unified system.</p>
<p>I hope this description will help someone in the future doing something similar and avoid the pains I had to trod through. Please don’t try to specialize the serializer to do anything ‘specific’, you will have pains writing the deserializer. Just write a tool to modify the json instead.</p>
<p>With that this is the end of this small write up. I did not come up with the entire thing myself; I had to do quite a lot of research and looking up and seeing other people’s code before coming to this solution. RTTR has its own example of how to do json serialization, and it was from their code that I solved the issues with instances and variants. </p>
<p><a target="_blank" rel="noopener" href="https://github.com/ShumWengSang/Reflection-Json-Serializer">Here is the Github link</a>  to the source code used for examples here.</p>

                </div>
                
                        <section class="post-tags">
                            <div>
                                <span>Tag(s):</span>
                                <span class="tag">
                                    
                                        
                                            <a href="/tags/GameDev/"># GameDev</a>
                                            
                                            <a href="/tags/C/"># C++</a>
                                            
                                            <a href="/tags/GameEngine/"># GameEngine</a>
                                            
                                                
                                </span>
                            </div>
                            <div>
                                <a href="javascript:window.history.back();">back</a>
                                <span>· </span>
                                <a href="/">home</a>
                            </div>
                        </section>
                        <section class="post-nav">
                            
                                <a class="prev" rel="prev" href="/asset-registry/">
                                    Implementing An Asset Registry
                                </a>
                                
                                    
                                        <a class="next" rel="next" href="/why_mvc/">
                                            Why MVC?
                                        </a>
                                        
                        </section>
            </div>
            <div class="column col-xl-2">
                
                    
                        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
                            
            </div>
        </article>
</div>
        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
<!-- © 0x00000000.dev |  -->
        <span>Powered by <a href="https://hexo.io" target="_blank">Hexo</a></span>
    </div>
</footer>

    </div>


</body><script>!function(e,t){var r=function(){t(e.lazySizes),e.removeEventListener("lazyunveilread",r,!0)};t=t.bind(null,e,e.document),"object"==typeof module&&module.exports?t(require("lazysizes")):e.lazySizes?r():e.addEventListener("lazyunveilread",r,!0)}(window,function(u,a,d){"use strict";var i,n,s,l,t,r,p,o,c,f,m,y=d&&d.cfg,e=a.createElement("img"),g="sizes"in e&&"srcset"in e,h=/\s+\d+h/g,e=(n=/\s+(\d+)(w|h)\s+(\d+)(w|h)/,s=Array.prototype.forEach,function(){function r(e){var t,r=e.getAttribute(lazySizesConfig.srcsetAttr);r&&(t=r.match(n))&&((t="w"==t[2]?t[1]/t[3]:t[3]/t[1])&&e.setAttribute("data-aspectratio",t),e.setAttribute(lazySizesConfig.srcsetAttr,r.replace(h,"")))}function e(e){var t;e.detail.instance==d&&((t=e.target.parentNode)&&"PICTURE"==t.nodeName&&s.call(t.getElementsByTagName("source"),r),r(e.target))}function t(){i.currentSrc&&a.removeEventListener("lazybeforeunveil",e)}var i=a.createElement("img");a.addEventListener("lazybeforeunveil",e),i.onload=t,i.onerror=t,i.srcset="data:,a 1w 1h",i.complete&&t()});function z(e,t){return e.w-t.w}function v(e,t,r,i){l.push({c:t,u:r,w:+i})}function b(e,t){var r,i=e.getAttribute("srcset")||e.getAttribute(y.srcsetAttr);!i&&t&&(i=e._lazypolyfill?e._lazypolyfill._set:e.getAttribute(y.srcAttr)||e.getAttribute("src")),e._lazypolyfill&&e._lazypolyfill._set==i||(r=o(i||""),t&&e.parentNode&&(r.isPicture="PICTURE"==e.parentNode.nodeName.toUpperCase(),r.isPicture&&u.matchMedia&&(d.aC(e,"lazymatchmedia"),c())),r._set=i,Object.defineProperty(e,"_lazypolyfill",{value:r,writable:!0}))}function w(e){var t,r,i,a,n,s,l,o,c=e;if(b(c,!0),(a=c._lazypolyfill).isPicture)for(r=0,i=(t=e.parentNode.getElementsByTagName("source")).length;r<i;r++)if(y.supportsType(t[r].getAttribute("type"),e)&&f(t[r].getAttribute("media"))){c=t[r],b(c),a=c._lazypolyfill;break}return 1<a.length?(s=c.getAttribute("sizes")||"",s=p.test(s)&&parseInt(s,10)||d.gW(e,e.parentNode),a.d=(l=e,o=u.devicePixelRatio||1,l=d.getX&&d.getX(l),Math.min(l||o,2.5,o)),!a.src||!a.w||a.w<s?(a.w=s,n=function(e){for(var t,r,i=e.length,a=e[i-1],n=0;n<i;n++)if((a=e[n]).d=a.w/e.w,a.d>=e.d){!a.cached&&(t=e[n-1])&&t.d>e.d-.13*Math.pow(e.d,2.2)&&(r=Math.pow(t.d-.6,1.6),t.cached&&(t.d+=.15*r),t.d+(a.d-e.d)*r>e.d&&(a=t));break}return a}(a.sort(z)),a.src=n):n=a.src):n=a[0],n}function A(e){var t;g&&e.parentNode&&"PICTURE"!=e.parentNode.nodeName.toUpperCase()||(t=w(e))&&t.u&&e._lazypolyfill.cur!=t.u&&(e._lazypolyfill.cur=t.u,t.cached=!0,e.setAttribute(y.srcAttr,t.u),e.setAttribute("src",t.u))}y.supportsType||(y.supportsType=function(e){return!e}),u.HTMLPictureElement&&g?!d.hasHDescriptorFix&&a.msElementsFromPoint&&(d.hasHDescriptorFix=!0,e()):u.picturefill||y.pf||(y.pf=function(e){var t,r;if(!u.picturefill)for(t=0,r=e.elements.length;t<r;t++)i(e.elements[t])},p=/^\s*\d+\.*\d*px\s*$/,t=/(([^,\s].[^\s]+)\s+(\d+)w)/g,r=/\s/,c=function(){var e,r;function t(){for(var e=0,t=r.length;e<t;e++)i(r[e])}c.init||(c.init=!0,addEventListener("resize",(r=a.getElementsByClassName("lazymatchmedia"),function(){clearTimeout(e),e=setTimeout(t,66)})))},f=function(e){return u.matchMedia?(f=function(e){return!e||(matchMedia(e)||{}).matches})(e):!e},A.parse=o=function(e){return l=[],(e=e.trim()).replace(h,"").replace(t,v),l.length||!e||r.test(e)||l.push({c:e,u:e,w:99}),l},i=A,y.loadedClass&&y.loadingClass&&(m=[],['img[sizes$="px"][srcset].',"picture > img:not([srcset])."].forEach(function(e){m.push(e+y.loadedClass),m.push(e+y.loadingClass)}),y.pf({elements:a.querySelectorAll(m.join(", "))})))});</script><script>!function(e,t){t=t(e,e.document);e.lazySizes=t,"object"==typeof module&&module.exports&&(module.exports=t)}(window,function(a,m){"use strict";if(m.getElementsByClassName){var z,n,i,t,s,o,y=m.documentElement,r=a.Date,l=a.HTMLPictureElement,c="addEventListener",h="getAttribute",d=a[c],u=a.setTimeout,f=a.requestAnimationFrame||u,v=a.requestIdleCallback,g=/^picture$/i,p=["load","error","lazyincluded","_lazyloaded"],C={},b=Array.prototype.forEach,A=function(e,t){return C[t]||(C[t]=new RegExp("(\\s|^)"+t+"(\\s|$)")),C[t].test(e[h]("class")||"")&&C[t]},E=function(e,t){A(e,t)||e.setAttribute("class",(e[h]("class")||"").trim()+" "+t)},_=function(e,t){(t=A(e,t))&&e.setAttribute("class",(e[h]("class")||"").replace(t," "))},w=function(t,n,e){var a=e?c:"removeEventListener";e&&w(t,n),p.forEach(function(e){t[a](e,n)})},M=function(e,t,n,a,i){var s=m.createEvent("Event");return(n=n||{}).instance=ue,s.initEvent(t,!a,!i),s.detail=n,e.dispatchEvent(s),s},N=function(e,t){var n;!l&&(n=a.picturefill||z.pf)?(t&&t.src&&!e[h]("srcset")&&e.setAttribute("srcset",t.src),n({reevaluate:!0,elements:[e]})):t&&t.src&&(e.src=t.src)},x=function(e,t){return(getComputedStyle(e,null)||{})[t]},W=function(e,t,n){for(n=n||e.offsetWidth;n<z.minSize&&t&&!e._lazysizesWidth;)n=t.offsetWidth,t=t.parentNode;return n},T=(s=[],o=t=[],he._lsFlush=ye,he),e=function(n,e){return e?function(){T(n)}:function(){var e=this,t=arguments;T(function(){n.apply(e,t)})}},B=function(e){var t,n,a=function(){t=null,e()},i=function(){var e=r.now()-n;e<99?u(i,99-e):(v||a)(a)};return function(){n=r.now(),t=t||u(i,99)}};!function(){var e,t={lazyClass:"lazyload",loadedClass:"lazyloaded",loadingClass:"lazyloading",preloadClass:"lazypreload",errorClass:"lazyerror",autosizesClass:"lazyautosizes",srcAttr:"data-src",srcsetAttr:"data-srcset",sizesAttr:"data-sizes",minSize:40,customMedia:{},init:!0,expFactor:1.5,hFac:.8,loadMode:2,loadHidden:!0,ricTimeout:0,throttleDelay:125};for(e in z=a.lazySizesConfig||a.lazysizesConfig||{},t)e in z||(z[e]=t[e]);a.lazySizesConfig=z,u(function(){z.init&&ze()})}();var F,S,L,R,k,D,H,O,P,$,I,q,j,G,J,K,Q,U,V,X,Y,Z,ee,te,ne,ae,ie,se,oe,re,le,ce,de,ue,fe=(V=/^img$/i,X=/^iframe$/i,Y="onscroll"in a&&!/(gle|ing)bot/.test(navigator.userAgent),te=-1,j=pe,J=ee=Z=0,K=z.throttleDelay,Q=z.ricTimeout,U=v&&49<Q?function(){v(Ce,{timeout:Q}),Q!==z.ricTimeout&&(Q=z.ricTimeout)}:e(function(){u(Ce)},!0),ae=e(be),ie=function(e){ae({target:e.target})},se=e(function(t,e,n,a,i){var s,o,r,l;(r=M(t,"lazybeforeunveil",e)).defaultPrevented||(a&&(n?E(t,z.autosizesClass):t.setAttribute("sizes",a)),n=t[h](z.srcsetAttr),a=t[h](z.srcAttr),i&&(o=(s=t.parentNode)&&g.test(s.nodeName||"")),l=e.firesLoad||"src"in t&&(n||a||o),r={target:t},E(t,z.loadingClass),l&&(clearTimeout(L),L=u(ve,2500),w(t,ie,!0)),o&&b.call(s.getElementsByTagName("source"),Ae),n?t.setAttribute("srcset",n):a&&!o&&(X.test(t.nodeName)?function(t,n){try{t.contentWindow.location.replace(n)}catch(e){t.src=n}}(t,a):t.src=a),i&&(n||o)&&N(t,{src:a})),t._lazyRace&&delete t._lazyRace,_(t,z.lazyClass),T(function(){var e=t.complete&&1<t.naturalWidth;l&&!e||(e&&E(t,"ls-is-cached"),be(r),t._lazyCache=!0,u(function(){"_lazyCache"in t&&delete t._lazyCache},9))},!0)}),re=function(){var e;S||(r.now()-k<999?u(re,999):(e=B(function(){z.loadMode=3,ne()}),S=!0,z.loadMode=3,ne(),d("scroll",function(){3==z.loadMode&&(z.loadMode=2),e()},!0)))},{_:function(){k=r.now(),ue.elements=m.getElementsByClassName(z.lazyClass),F=m.getElementsByClassName(z.lazyClass+" "+z.preloadClass),d("scroll",ne,!0),d("resize",ne,!0),a.MutationObserver?new MutationObserver(ne).observe(y,{childList:!0,subtree:!0,attributes:!0}):(y[c]("DOMNodeInserted",ne,!0),y[c]("DOMAttrModified",ne,!0),setInterval(ne,999)),d("hashchange",ne,!0),["focus","mouseover","click","load","transitionend","animationend","webkitAnimationEnd"].forEach(function(e){m[c](e,ne,!0)}),/d$|^c/.test(m.readyState)?re():(d("load",re),m[c]("DOMContentLoaded",ne),u(re,2e4)),ue.elements.length?(pe(),T._lsFlush()):ne()},checkElems:ne=function(e){var t;(e=!0===e)&&(Q=33),G||(G=!0,(t=K-(r.now()-J))<0&&(t=0),e||t<9?U():u(U,t))},unveil:oe=function(e){var t,n=V.test(e.nodeName),a=n&&(e[h](z.sizesAttr)||e[h]("sizes")),i="auto"==a;(!i&&S||!n||!e[h]("src")&&!e.srcset||e.complete||A(e,z.errorClass)||!A(e,z.lazyClass))&&(t=M(e,"lazyunveilread").detail,i&&me.updateElem(e,!0,e.offsetWidth),e._lazyRace=!0,ee++,se(e,t,i,a,n))}}),me=(ce=e(function(e,t,n,a){var i,s,o;if(e._lazysizesWidth=a,e.setAttribute("sizes",a+="px"),g.test(t.nodeName||""))for(s=0,o=(i=t.getElementsByTagName("source")).length;s<o;s++)i[s].setAttribute("sizes",a);n.detail.dataAttr||N(e,n.detail)}),{_:function(){le=m.getElementsByClassName(z.autosizesClass),d("resize",de)},checkElems:de=B(function(){var e,t=le.length;if(t)for(e=0;e<t;e++)Ee(le[e])}),updateElem:Ee}),ze=function(){ze.i||(ze.i=!0,me._(),fe._())};return ue={cfg:z,autoSizer:me,loader:fe,init:ze,uP:N,aC:E,rC:_,hC:A,fire:M,gW:W,rAF:T}}function ye(){var e=o;for(o=t.length?s:t,i=!(n=!0);e.length;)e.shift()();n=!1}function he(e,t){n&&!t?e.apply(this,arguments):(o.push(e),i||(i=!0,(m.hidden?u:f)(ye)))}function ve(e){ee--,e&&!(ee<0)&&e.target||(ee=0)}function ge(e){return(q=null==q?"hidden"==x(m.body,"visibility"):q)||"hidden"!=x(e.parentNode,"visibility")&&"hidden"!=x(e,"visibility")}function pe(){var e,t,n,a,i,s,o,r,l,c,d,u,f=ue.elements;if((R=z.loadMode)&&ee<8&&(e=f.length)){for(t=0,te++,c=!z.expand||z.expand<1?500<y.clientHeight&&500<y.clientWidth?500:370:z.expand,d=(ue._defEx=c)*z.expFactor,u=z.hFac,q=null,Z<d&&ee<1&&2<te&&2<R&&!m.hidden?(Z=d,te=0):Z=1<R&&1<te&&ee<6?c:0;t<e;t++)if(f[t]&&!f[t]._lazyRace)if(Y)if(l!==(s=!(r=f[t][h]("data-expand"))||!(s=+r)?Z:s)&&(D=innerWidth+s*u,H=innerHeight+s,o=-1*s,l=s),n=f[t].getBoundingClientRect(),(I=n.bottom)>=o&&(O=n.top)<=H&&($=n.right)>=o*u&&(P=n.left)<=D&&(I||$||P||O)&&(z.loadHidden||ge(f[t]))&&(S&&ee<3&&!r&&(R<3||te<4)||function(e,t){var n,a=e,i=ge(e);for(O-=t,I+=t,P-=t,$+=t;i&&(a=a.offsetParent)&&a!=m.body&&a!=y;)(i=0<(x(a,"opacity")||1))&&"visible"!=x(a,"overflow")&&(n=a.getBoundingClientRect(),i=$>n.left&&P<n.right&&I>n.top-1&&O<n.bottom+1);return i}(f[t],s))){if(oe(f[t]),i=!0,9<ee)break}else!i&&S&&!a&&ee<4&&te<4&&2<R&&(F[0]||z.preloadAfterLoad)&&(F[0]||!r&&(I||$||P||O||"auto"!=f[t][h](z.sizesAttr)))&&(a=F[0]||f[t]);else oe(f[t]);a&&!i&&oe(a)}}function Ce(){G=!1,J=r.now(),j()}function be(e){var t=e.target;t._lazyCache?delete t._lazyCache:(ve(e),E(t,z.loadedClass),_(t,z.loadingClass),w(t,ie),M(t,"lazyloaded"))}function Ae(e){var t,n=e[h](z.srcsetAttr);(t=z.customMedia[e[h]("data-media")||e[h]("media")])&&e.setAttribute("media",t),n&&e.setAttribute("srcset",n)}function Ee(e,t,n){var a=e.parentNode;a&&(n=W(e,a,n),(t=M(e,"lazybeforesizes",{width:n,dataAttr:!!t})).defaultPrevented||(n=t.detail.width)&&n!==e._lazysizesWidth&&ce(e,a,t,n))}});lazySizes.init();</script></html>